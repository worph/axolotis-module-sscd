{"version":3,"sources":["../../../node_modules/eventemitter3/index.js","../src/services/src/sscdNameSpace.ts","../src/services/src/world.ts","../src/services/src/utils/extend.ts","../src/services/src/shapes/shape.ts","../src/services/src/shapes/composite_shape.ts","../src/services/src/shapes/capsule.ts","../src/services/src/shapes/circle.ts","../src/services/src/shapes/line.ts","../src/services/src/shapes/lines_strip.ts","../src/services/src/shapes/rectangle.ts","../src/services/src/shapes/shapes_collider.ts","../src/services/src/utils/aabb.ts","../src/services/src/utils/math.ts","../src/services/src/utils/vector.ts","../src/services/src/tilemap.ts","../src/services/simple-collision/SimpleCollisionDetection.ts"],"names":["require_eventemitter3","__commonJSMin","exports","module","has","prefix","Events","EE","fn","context","once","addListener","emitter","event","listener","evt","clearEvent","EventEmitter","names","events","name","handlers","i","l","ee","listeners","a1","a2","a3","a4","a5","len","args","length","j","SSCD","params","rows","_i","columns","_j","tags","ret","obj","aabb","min_i","min_j","max_i","max_j","grids","curr_grid_chunk","key","grid_chunk","curr_aabb","collision_tags","outlist","out_list","ret_objs_count","position","distance","direction","fov_angle","circle","angle","vector","collision_tags_val","grid_size","found","curr_obj","grid","already_tests","x","src","target","canvas","camera_pos","show_grid","show_aabb","ctx","render_list","message","base","child","prop","force","iterations","factor_self","factor_other","push_vector_other","push_vector_self","push_vector","collide","center","other_center","opacity","fill_color","stroke_color","r","g","b","box","objects","shape","offset","size","standing","radius","source","dest","pos","points","closed","to","from","a","rect","v","line","linestrip","lines","p1","p2","r1","r2","r3","r4","linesstrip","strip1","strip2","lines1","lines2","composite","other","comp_shapes","other_shapes","circle_pos","rect_center","min_x","min_y","max_x","max_y","push_pos_x","push_pos_y","push_size_x","push_size_y","degrees","radians","dx","dy","P1","P2","deltaY","deltaX","p","w","l2","t","p0","p3","s1_x","s1_y","s2_x","s2_y","s","l1","a0","max","da","y","by","val","min","rad","func","tile_size","additional_params","index","collision","tilesize","matrix","import_eventemitter3","ADD","REMOVE","SimpleCollisionDetection","callback","param","collision_list"],"mappings":"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","sourcesContent":["'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","// set namespace\r\nexport let SSCD:any = {};\r\n","/*\r\n * Physical world contains a grid of shapes you can efficiently check collision with\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// a collision world. you create an instance of this class and add bodies to it to check collision.\r\n//\r\n// params is an optional dictionary with the following optional settings:\r\n//\t\t\tgrid_size: \t\tfor better performance, the world is divided into a grid of world-chunks and when collision is checked we will\r\n//\t\t\t\t\t\t\t\tonly match objects from the same chunk(s) on grid. this param defines the grid size. default to 512.\r\n//\t\t\tgrid_error: \tmax amount of pixels a shape can move before updating the collision grid. default to 2.\r\n//\t\t\t\t\t\t\t\tyou can increase this number to make moving objects more efficient for the price of sometimes\r\n//\t\t\t\t\t\t\t\tless accurate collision around the edges. set to 0 if you want to always update grid (useful if all your moving objects move fast)\r\nimport {SSCD} from \"./sscdNameSpace\"\r\nSSCD.World = function(params) {\r\n\r\n\tthis.__init_world(params);\r\n\r\n};\r\n\r\n// collision world prototype\r\nSSCD.World.prototype = {\r\n\r\n\t// init the world\r\n\t__init_world: function(params) {\r\n\t\t// set defaults\r\n\t\tparams = params || {};\r\n\t\tparams.grid_size = params.grid_size || 512;\r\n\t\tparams.grid_error = params.grid_error !== undefined ? params.grid_error : 2;\r\n\r\n\t\t// create grid and set params\r\n\t\tthis.__grid = {};\r\n\t\tthis.__params = params;\r\n\r\n\t\t// all the shapes currently in this world\r\n\t\tthis.__all_shapes = {};\r\n\r\n\t\t// create the empty collision flags dictionary\r\n\t\tthis.__collision_tags = {};\r\n\t\tthis.__next_coll_tag = 0;\r\n\t},\r\n\r\n\t// define a new collision tag\r\n\t__create_collision_tag: function(name) {\r\n\t\t// if already exist throw exception\r\n\t\tif (this.__collision_tags[name]) {\r\n\t\t\tthrow new SSCD.IllegalActionError(\"Collision tag named '\" + name + \"' already exist!\");\r\n\t\t}\r\n\r\n\t\t// set collision tag\r\n\t\tthis.__collision_tags[name] = 1 << this.__next_coll_tag++;\r\n\t},\r\n\r\n\t// all-tags flags\r\n\t_ALL_TAGS_VAL: Number.MAX_SAFE_INTEGER || 4294967295,\r\n\r\n\t// clean-up world memory\r\n\tcleanup: function() {\r\n\t\t// iterate over grid rows\r\n\t\tlet rows = Object.keys(this.__grid);\r\n\t\tfor (let _i = 0; _i < rows.length; ++_i) {\r\n\t\t\tlet i = rows[_i];\r\n\r\n\t\t\t// iterate over grid columns in current row:\r\n\t\t\tlet columns = Object.keys(this.__grid[i]);\r\n\t\t\tfor (let _j = 0; _j < columns.length; ++_j) {\r\n\t\t\t\tlet j = columns[_j];\r\n\r\n\t\t\t\t// if empty grid chunk delete it\r\n\t\t\t\tif (this.__grid[i][j].length === 0) {\r\n\t\t\t\t\tdelete this.__grid[i][j];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t// if no more columns are left in current row delete the row itself\r\n\t\t\tif (Object.keys(this.__grid[i]).length === 0) {\r\n\t\t\t\tdelete this.__grid[i];\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// get the hash value of a list of collision tags or individual tag\r\n\t// tags can either be a single string or a list of strings\r\n\t__get_tags_value: function(tags) {\r\n\t\t// special case: undefined return all possible tags\r\n\t\tif (tags === undefined) {\r\n\t\t\treturn this._ALL_TAGS_VAL;\r\n\t\t}\r\n\r\n\t\t// single tag:\r\n\t\tif (typeof tags === \"string\") {\r\n\t\t\treturn this.__collision_tag(tags);\r\n\t\t}\r\n\r\n\t\t// else, assume a list\r\n\t\tlet ret = 0;\r\n\t\tfor (let i = 0; i < tags.length; ++i) {\r\n\t\t\tret |= this.__collision_tag(tags[i]);\r\n\t\t}\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// return the value of a single collision tag, define it if not exist\r\n\t__collision_tag: function(name) {\r\n\t\t// if tag doesn't exist create it\r\n\t\tif (this.__collision_tags[name] === undefined) {\r\n\t\t\tthis.__create_collision_tag(name);\r\n\t\t}\r\n\r\n\t\t// return collision tag\r\n\t\treturn this.__collision_tags[name];\r\n\t},\r\n\r\n\t// get the grid range that this object touches\r\n\t__get_grid_range: function(obj) {\r\n\t\t// get bounding box\r\n\t\tlet aabb = obj.get_aabb();\r\n\r\n\t\t// calc all grid chunks this shape touches\r\n\t\tlet min_i = Math.floor((aabb.position.x) / this.__params.grid_size);\r\n\t\tlet min_j = Math.floor((aabb.position.y) / this.__params.grid_size);\r\n\t\tlet max_i = Math.floor((aabb.position.x + aabb.size.x) / this.__params.grid_size);\r\n\t\tlet max_j = Math.floor((aabb.position.y + aabb.size.y) / this.__params.grid_size);\r\n\r\n\t\t// return grid range\r\n\t\treturn {\r\n\t\t\tmin_x: min_i,\r\n\t\t\tmin_y: min_j,\r\n\t\t\tmax_x: max_i,\r\n\t\t\tmax_y: max_j\r\n\t\t};\r\n\t},\r\n\r\n\t// add collision object to world\r\n\tadd: function(obj) {\r\n\t\t// if object already in world throw exception\r\n\t\tif (obj.__world) {\r\n\t\t\tthrow new SSCD.IllegalActionError(\"Object to add is already in a collision world!\");\r\n\t\t}\r\n\r\n\t\t// get grid range\r\n\t\tlet grids = this.__get_grid_range(obj);\r\n\r\n\t\t// add shape to all grid parts\r\n\t\tfor (let i = grids.min_x; i <= grids.max_x; ++i) {\r\n\t\t\tfor (let j = grids.min_y; j <= grids.max_y; ++j) {\r\n\t\t\t\t// make sure lists exist\r\n\t\t\t\tthis.__grid[i] = this.__grid[i] || {};\r\n\t\t\t\tthis.__grid[i][j] = this.__grid[i][j] || [];\r\n\r\n\t\t\t\t// get current grid chunk\r\n\t\t\t\tlet curr_grid_chunk = this.__grid[i][j];\r\n\r\n\t\t\t\t// add object to grid chunk\r\n\t\t\t\tcurr_grid_chunk.push(obj);\r\n\r\n\t\t\t\t// add chunk to shape chunks list\r\n\t\t\t\tobj.__grid_chunks.push(curr_grid_chunk);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// set world and grid chunks boundaries\r\n\t\tobj.__world = this;\r\n\t\tobj.__grid_bounderies = grids;\r\n\t\tobj.__last_insert_aabb = obj.get_aabb().clone();\r\n\r\n\t\t// add to list of all shapes\r\n\t\tthis.__all_shapes[obj.get_id()] = obj;\r\n\r\n\t\t// return the newly added object\r\n\t\treturn obj;\r\n\t},\r\n\r\n\t// return all shapes in world\r\n\tget_all_shapes: function() {\r\n\t\tlet ret = [];\r\n\t\tfor (let key in this.__all_shapes) {\r\n\t\t\tif (this.__all_shapes.hasOwnProperty(key)) {\r\n\t\t\t\tret.push(this.__all_shapes[key]);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// remove object from world\r\n\tremove: function(obj) {\r\n\t\t// if object is not in this world throw exception\r\n\t\tif (obj.__world !== this) {\r\n\t\t\tthrow new SSCD.IllegalActionError(\"Object to remove is not in this collision world!\");\r\n\t\t}\r\n\r\n\t\t// remove from all the grid chunks\r\n\t\tfor (let i = 0; i < obj.__grid_chunks.length; ++i) {\r\n\t\t\t// get current grid chunk\r\n\t\t\tlet grid_chunk = obj.__grid_chunks[i];\r\n\r\n\t\t\t// remove object from grid\r\n\t\t\tfor (let j = 0; j < grid_chunk.length; ++j) {\r\n\t\t\t\tif (grid_chunk[j] === obj) {\r\n\t\t\t\t\tgrid_chunk.splice(j, 1);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// remove from list of all shapes\r\n\t\tdelete this.__all_shapes[obj.get_id()];\r\n\r\n\t\t// clear shape world chunks and world pointer\r\n\t\tobj.__grid_chunks = [];\r\n\t\tobj.__world = null;\r\n\t\tobj.__grid_bounderies = null;\r\n\t\tobj.__last_insert_aabb = null;\r\n\t},\r\n\r\n\t// update object grid when it moves or resize etc.\r\n\t// this function is used internally by the collision shapes.\r\n\t__update_shape_grid: function(obj) {\r\n\t\tlet curr_aabb = obj.get_aabb();\r\n\t\tif (this.__params.grid_error === 0 ||\r\n\t\t\t((Math.abs(curr_aabb.position.x - obj.__last_insert_aabb.position.x) > this.__params.grid_error) ||\r\n\t\t\t\t(Math.abs(curr_aabb.position.y - obj.__last_insert_aabb.position.y) > this.__params.grid_error) ||\r\n\t\t\t\t(Math.abs(curr_aabb.size.x - obj.__last_insert_aabb.size.x) > this.__params.grid_error) ||\r\n\t\t\t\t(Math.abs(curr_aabb.size.y - obj.__last_insert_aabb.size.y) > this.__params.grid_error))) {\r\n\t\t\tthis.remove(obj);\r\n\t\t\tthis.add(obj);\r\n\t\t}\r\n\t},\r\n\r\n\t// check collision and return first object found.\r\n\t// obj: object to check collision with (vector or collision shape)\r\n\t// collision_tags: optional single or multiple tags to check collision with\r\n\t// return: first object collided with, or null if don't collide with anything\r\n\tpick_object: function(obj, collision_tags) {\r\n\t\tlet outlist = [];\r\n\t\tif (this.test_collision(obj, collision_tags, outlist, 1)) {\r\n\t\t\treturn outlist[0];\r\n\t\t}\r\n\t\treturn null;\r\n\t},\r\n\r\n\t// test collision with vector or object\r\n\t// @param obj: object to check collision with, can be either Vector (for point collision) or any collision shape.\r\n\t// @param collision_tags: optional string or list of strings of tags to match collision with. if undefined will accept all tags\r\n\t// @param out_list: optional output list. if provided, will be filled with all objects collided with. note: collision is more efficient if not provided.\r\n\t// @param ret_objs_count: if provided, will limit returned objects to given count.\r\n\t// @return true if collided with anything, false otherwise.\r\n\ttest_collision: function(obj, collision_tags, out_list, ret_objs_count) {\r\n\t\t// default collision flags\r\n\t\tcollision_tags = this.__get_tags_value(collision_tags);\r\n\r\n\t\t// handle vector\r\n\t\tif (obj instanceof SSCD.Vector) {\r\n\t\t\treturn this.__test_collision_point(obj, collision_tags, out_list, ret_objs_count);\r\n\t\t}\r\n\t\t// handle collision with shape\r\n\t\tif (obj.is_shape) {\r\n\t\t\treturn this.__test_collision_shape(obj, collision_tags, out_list, ret_objs_count);\r\n\t\t}\r\n\t},\r\n\r\n\r\n\t// test collision with a field of view.\r\n\t// a field of view is basically a pizza-like shape starting from the center.\r\n\t// @param position: source position (vector).\r\n\t// @param distance: fov distance.\r\n\t// @param direction: look-at direction in degrees (0 = looking right, 90 = looking down, etc.).\r\n\t// @param fov_angle: angle range in degrees.\r\n\t// @param collision_tags: optional string or list of strings of tags to match collision with. if undefined will accept all tags\r\n\t// @param out_list: optional output list. if provided, will be filled with all objects collided with. note: collision is more efficient if not provided.\r\n\t// @return true if collided with anything, false otherwise.\r\n\ttest_fov: function(position, distance, direction, fov_angle, collision_tags, out_list) {\r\n\t\t// default collision flags\r\n\t\tcollision_tags = this.__get_tags_value(collision_tags);\r\n\r\n\t\t// default out-list if not provided\r\n\t\tout_list = out_list || [];\r\n\r\n\t\t// create a circle and check basic collision with it\r\n\t\tlet circle = new SSCD.Circle(position, distance);\r\n\t\tthis.__test_collision_shape(circle, collision_tags, out_list,null);\r\n\r\n\t\t// now iterate over collided objects and check angle\r\n\t\tfor (let i = out_list.length - 1; i >= 0; --i) {\r\n\t\t\t// get angle between source position and the body\r\n\t\t\tlet angle = position.angle_from(out_list[i].__position);\r\n\t\t\tif (SSCD.Math.angles_dis(direction, angle) > fov_angle) {\r\n\t\t\t\tout_list.splice(i, 1);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// return if got collision\r\n\t\treturn out_list.length > 0;\r\n\t},\r\n\r\n\t// test collision for given point\r\n\t// see test_collision comment for more info\r\n\t__test_collision_point: function(vector, collision_tags_val, out_list, ret_objs_count) {\r\n\t\t// get current grid size\r\n\t\tlet grid_size = this.__params.grid_size;\r\n\r\n\t\t// get the grid chunk to test collision with\r\n\t\tlet i = Math.floor((vector.x) / grid_size);\r\n\t\tlet j = Math.floor((vector.y) / grid_size);\r\n\r\n\t\t// if grid chunk is not in use return empty list\r\n\t\tif (this.__grid[i] === undefined || this.__grid[i][j] === undefined) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t\t// get current grid chunk\r\n\t\tlet grid_chunk = this.__grid[i][j];\r\n\r\n\t\t// iterate over all objects in current grid chunk and add them to render list\r\n\t\tlet found = 0;\r\n\t\tfor (let i = 0; i < grid_chunk.length; ++i) {\r\n\t\t\t// get current object to test\r\n\t\t\tlet curr_obj = grid_chunk[i];\r\n\r\n\t\t\t// if collision tags don't match skip this object\r\n\t\t\tif (!curr_obj.collision_tags_match(collision_tags_val)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// if collide with object:\r\n\t\t\tif (this.__do_collision(curr_obj, vector)) {\r\n\t\t\t\t// if got collision list to fill, add object and set return value to true\r\n\t\t\t\tif (out_list) {\r\n\t\t\t\t\tfound++;\r\n\t\t\t\t\tout_list.push(curr_obj);\r\n\t\t\t\t\tif (ret_objs_count && found >= ret_objs_count) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// if don't have collision list to fill simply return true\r\n\t\t\t\telse {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// return if collided \r\n\t\t// note: get here only if got list to fill or if no collision found\r\n\t\treturn found > 0;\r\n\t},\r\n\r\n\t// test collision with other shape\r\n\t// see test_collision comment for more info\r\n\t__test_collision_shape: function(obj, collision_tags_val, out_list, ret_objs_count) {\r\n\t\tlet grid;\r\n\r\n\t\t// if shape is in this world, use its grid range from cache\r\n\t\tif (obj.__world === this) {\r\n\t\t\tgrid = obj.__grid_bounderies;\r\n\t\t}\r\n\t\t// if not in world, generate grid range\r\n\t\telse {\r\n\t\t\tgrid = this.__get_grid_range(obj);\r\n\t\t}\r\n\r\n\t\t// for return value\r\n\t\tlet found = 0;\r\n\r\n\t\t// so we won't test same objects multiple times\r\n\t\tlet already_tests = {};\r\n\r\n\t\t// iterate over grid this shape touches\r\n\t\tfor (let i = grid.min_x; i <= grid.max_x; ++i) {\r\n\t\t\t// skip empty rows\r\n\t\t\tif (this.__grid[i] === undefined) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t// iterate on current grid row\r\n\t\t\tfor (let j = grid.min_y; j <= grid.max_y; ++j) {\r\n\t\t\t\tlet curr_grid_chunk = this.__grid[i][j];\r\n\r\n\t\t\t\t// skip empty grid chunks\r\n\t\t\t\tif (curr_grid_chunk === undefined) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over objects in grid chunk and check collision\r\n\t\t\t\tfor (let x = 0; x < curr_grid_chunk.length; ++x) {\r\n\t\t\t\t\t// get current object\r\n\t\t\t\t\tlet curr_obj = curr_grid_chunk[x];\r\n\r\n\t\t\t\t\t// make sure object is not self\r\n\t\t\t\t\tif (curr_obj === obj) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// check if this object was already tested\r\n\t\t\t\t\tif (already_tests[curr_obj.get_id()]) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\talready_tests[curr_obj.get_id()] = true;\r\n\r\n\t\t\t\t\t// if collision tags don't match skip this object\r\n\t\t\t\t\tif (!curr_obj.collision_tags_match(collision_tags_val)) {\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\t// if collide with object:\r\n\t\t\t\t\tif (this.__do_collision(curr_obj, obj)) {\r\n\t\t\t\t\t\t// if got collision list to fill, add object and set return value to true\r\n\t\t\t\t\t\tif (out_list) {\r\n\t\t\t\t\t\t\tfound++;\r\n\t\t\t\t\t\t\tout_list.push(curr_obj);\r\n\t\t\t\t\t\t\tif (ret_objs_count && found >= ret_objs_count) {\r\n\t\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t// if don't have collision list to fill simply return true\r\n\t\t\t\t\t\telse {\r\n\t\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// return if collided \r\n\t\t// note: get here only if got list to fill or if no collision found\r\n\t\treturn found > 0;\r\n\t},\r\n\r\n\t// do actual collision check between source and target\r\n\t__do_collision: function(src, target) {\r\n\t\treturn src.test_collide_with(target);\r\n\t},\r\n\r\n\t// debug-render all the objects in world\r\n\t// canvas: a 2d canvas object to render on.\r\n\t// camera_pos: optional, vector that represent the current camera position is 2d space.\r\n\t// show_grid: default to true, if set will render background grid that shows which grid chunks are currently active\r\n\t// show_aabb: default to true, if set will render objects axis-aligned bounding boxes\r\n\t// NOTE: this function will NOT clear canvas before rendering, if you render within a main loop its your responsibility.\r\n\trender: function(canvas, camera_pos, show_grid, show_aabb) {\r\n\t\t// set default camera pos if doesn't exist\r\n\t\tcamera_pos = camera_pos || SSCD.Vector.ZERO;\r\n\r\n\t\t// set default show_grid and show_aabb\r\n\t\tif (show_grid === undefined) {\r\n\t\t\tshow_grid = true;\r\n\t\t}\r\n\t\tif (show_aabb === undefined) {\r\n\t\t\tshow_aabb = true;\r\n\t\t}\r\n\r\n\t\t// get ctx and reset previous transformations\r\n\t\tlet ctx = canvas.getContext('2d');\r\n\t\tctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n\t\t// get current grid size\r\n\t\tlet grid_size = this.__params.grid_size;\r\n\r\n\t\t// get grid parts that are visible based on canvas size and camera position\r\n\t\tlet min_i = Math.floor((camera_pos.x) / grid_size);\r\n\t\tlet min_j = Math.floor((camera_pos.y) / grid_size);\r\n\t\tlet max_i = min_i + Math.ceil(canvas.width / grid_size);\r\n\t\tlet max_j = min_j + Math.ceil(canvas.height / grid_size);\r\n\r\n\t\t// a list of objects to render\r\n\t\tlet render_list = [];\r\n\r\n\t\t// iterate over grid\r\n\t\tfor (let i = min_i; i <= max_i; ++i) {\r\n\r\n\t\t\t// go over grid row\r\n\t\t\tfor (let j = min_j; j <= max_j; ++j) {\r\n\t\t\t\t// get current grid chunk\r\n\t\t\t\tlet curr_grid_chunk = undefined;\r\n\t\t\t\tif (this.__grid[i]) {\r\n\t\t\t\t\tcurr_grid_chunk = this.__grid[i][j];\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// render current grid chunk\r\n\t\t\t\tif (show_grid) {\r\n\t\t\t\t\tlet position = new SSCD.Vector(i * grid_size, j * grid_size).sub_self(camera_pos);\r\n\t\t\t\t\tctx.beginPath();\r\n\t\t\t\t\tctx.rect(position.x, position.y, grid_size - 1, grid_size - 1);\r\n\t\t\t\t\tctx.lineWidth = \"1\";\r\n\t\t\t\t\tif ((curr_grid_chunk === undefined) || (curr_grid_chunk.length === 0)) {\r\n\t\t\t\t\t\tctx.strokeStyle = 'rgba(100, 100, 100, 0.255)';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tctx.strokeStyle = 'rgba(255, 0, 0, 0.3)';\r\n\t\t\t\t\t}\r\n\t\t\t\t\tctx.stroke();\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// if current grid chunk has no objects skip\r\n\t\t\t\tif (curr_grid_chunk === undefined) {\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// iterate over all objects in current grid chunk and add them to render list\r\n\t\t\t\tfor (let x = 0; x < curr_grid_chunk.length; ++x) {\r\n\t\t\t\t\tlet curr_obj = curr_grid_chunk[x];\r\n\t\t\t\t\tif (render_list.indexOf(curr_obj) === -1) {\r\n\t\t\t\t\t\trender_list.push(curr_grid_chunk[x]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// now render all objects in render list\r\n\t\tfor (let i = 0; i < render_list.length; ++i) {\r\n\t\t\trender_list[i].render(ctx, camera_pos);\r\n\t\t\tif (show_aabb) {\r\n\t\t\t\trender_list[i].render_aabb(ctx, camera_pos);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n};\r\n\r\n\r\n// for illegal action exception\r\nSSCD.IllegalActionError = function(message) {\r\n\tthis.name = \"Illegal Action\";\r\n\tthis.message = (message || \"\");\r\n};\r\nSSCD.IllegalActionError.prototype = Error.prototype;\r\n","/*\r\n * Provide simple inheritance (extend prototype)\r\n * Author: Ronen Ness, 2015\r\n */\r\n\r\n// inherit base into child\r\n// base / child must be object's prototype (eg SSCD.something.prototype)\r\n// NOTE: don't use javascript built-ins so you won't mess up their prototypes.\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.extend = function(base, child) {\r\n\r\n\t// copy all properties\r\n\tfor (let prop in base) {\r\n\t\tif (child[prop])\r\n\t\t\tcontinue;\r\n\r\n\t\tchild[prop] = base[prop];\r\n\t}\r\n\r\n\t// create inits list (constructors)\r\n\t// this creates a function namd .init() that will call all the __init__() functions in the inheritance chain by the order it was extended.\r\n\tchild.__inits = child.__inits || [];\r\n\r\n\t// add parent init function\r\n\tif (base.__init__) {\r\n\t\tchild.__inits.push(base.__init__);\r\n\t}\r\n\r\n\t// set init function\r\n\tchild.init = function() {\r\n\t\tfor (let i = 0; i < this.__inits.length; ++i) {\r\n\t\t\tthis.__curr_init_func = this.__inits[i];\r\n\t\t\tthis.__curr_init_func();\r\n\t\t}\r\n\t\tdelete this.__curr_init_func;\r\n\t};\r\n};\r\n\r\n// for not-implemented exceptions\r\nSSCD.NotImplementedError = function(message) {\r\n\tthis.name = \"NotImplementedError\";\r\n\tthis.message = (message || \"\");\r\n};\r\nSSCD.NotImplementedError.prototype = Error.prototype;\r\n","/*\r\n * define the base class of any collision shape.\r\n * every type of shape should inherit from this class.\r\n * Author: Ronen Ness, 2015\r\n */\r\n\r\n// base shape class\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.Shape = function() {};\r\n\r\n// base shape prototype\r\nSSCD.Shape.prototype = {\r\n\r\n\t// shape type (need to be overrided by children)\r\n\t__type: \"shape\",\r\n\r\n\t// define the collision type of this shape (how collision is tested against it)\r\n\t__collision_type: null,\r\n\r\n\t// to detect if this object is a collision shape\r\n\tis_shape: true,\r\n\r\n\t// optional data or object you can attach to shapes\r\n\t__data: null,\r\n\r\n\t// to give unique id to every shape for internal usage\r\n\t__next_id: 0,\r\n\r\n\t// default type flags: everything\r\n\t__collision_tags: [],\r\n\t__collision_tags_val: SSCD.World.prototype._ALL_TAGS_VAL,\r\n\r\n\t// init the general shape\r\n\t__init__: function() {\r\n\t\t// create position and set default type\r\n\t\tthis.__position = new SSCD.Vector(0,0);\r\n\r\n\t\t// for collision-world internal usage\r\n\t\tthis.__grid_chunks = []; // list with world chunks this shape is in\r\n\t\tthis.__world = null; // the parent collision world\r\n\t\tthis.__grid_bounderies = null; // grid bounderies\r\n\t\tthis.__last_insert_aabb = null; // will store the aabb at the last time this shape grid was last updated\r\n\r\n\t\t// set unique ids\r\n\t\tthis.__id = SSCD.Shape.prototype.__next_id++;\r\n\t},\r\n\r\n\t// return the shape unique id\r\n\tget_id: function() {\r\n\t\treturn this.__id;\r\n\t},\r\n\r\n\t// set the collision tags of this shape.\r\n\t// for example, if you want this shape to be tagged as \"wall\", use:\r\n\t//\t\tshape.set_collision_tags(\"walls\");\r\n\t//\r\n\t// you can also set multiple tags, like this:\r\n\t//\t\tshape.set_collision_tags([\"walls\", \"glass\"]);\r\n\t//\r\n\t// note: set tags to null to reset all collision tags\r\n\t//\r\n\t// @param tags - string or list of strings to set as collision tags for this shape.\r\n\t//\t\t\r\n\tset_collision_tags: function(tags) {\r\n\t\t// can't set tags without world instance\r\n\t\tif (this.__world === null) {\r\n\t\t\tthrow new SSCD.IllegalActionError(\"Can't set tags for a shape that is not inside a collision world!\");\r\n\t\t}\r\n\r\n\t\t// special case - if tags is null, reset tags\r\n\t\tif (tags === null) {\r\n\t\t\tthis.__collision_tags = [];\r\n\t\t\tthis.__collision_tags_val = SSCD.World.prototype._ALL_TAGS_VAL;\r\n\t\t}\r\n\t\t// else, set tags\r\n\t\telse {\r\n\t\t\t// set the collision tag hash value\r\n\t\t\tthis.__collision_tags_val = this.__world.__get_tags_value(tags);\r\n\r\n\t\t\t// convert tags to array and store them\r\n\t\t\tif (!(tags instanceof Array)) {\r\n\t\t\t\ttags = [tags];\r\n\t\t\t}\r\n\t\t\tthis.__collision_tags = tags;\r\n\t\t}\r\n\r\n\t\t// if there's a hook to call when setting tags, call it\r\n\t\tif (this.__update_tags_hook) {\r\n\t\t\tthis.__update_tags_hook();\r\n\t\t}\r\n\r\n\t\t// return self\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// optional hook to call after updating collision tags\r\n\t__update_tags_hook: null,\r\n\r\n\t// return collision tag(s) (always return a list of strings)\r\n\tget_collision_tags: function() {\r\n\t\treturn this.__collision_tags;\r\n\t},\r\n\r\n\t// check if collision tags match given tags list.\r\n\t// @param tags - tags to check. can either be the tags numeric value, a single string, or a list of strings.\r\n\t// note: if provided string or list of strings this shape must be inside a collision world.\r\n\tcollision_tags_match: function(tags) {\r\n\t\t// if need to convert tags to their numeric value\r\n\t\tif (isNaN(tags)) {\r\n\t\t\t// if don't have collision world raise error\r\n\t\t\tif (this.__world === null) {\r\n\t\t\t\tthrow new SSCD.IllegalActionError(\"If you provide tags as string(s) the shape must be inside a collision world to convert them!\");\r\n\t\t\t}\r\n\t\t\ttags = this.__world.__get_tags_value(tags);\r\n\t\t}\r\n\r\n\t\t// check if tags match\r\n\t\treturn (this.__collision_tags_val & tags) !== 0;\r\n\t},\r\n\r\n\t// check collision with other object\r\n\t// @param obj - any other shape or vector.\r\n\ttest_collide_with: function(obj) {\r\n\t\treturn SSCD.CollisionManager.test_collision(this, obj);\r\n\t},\r\n\r\n\t// repeal an object from this object.\r\n\t// this means, in simple words, we push the other object outside to prevent penetration.\r\n\t// this works in a very simply way - it iterates and push the penetrating object outside from center until its no longer collided.\r\n\t// @param obj: object or vector to repeal (must have move() function).\r\n\t// @param force: force factor, the bigger this is the stronger / faster the repealing will be. default to 1.\r\n\t// @param iterations: max iterations of repeal-and-test-again routines. default to 1.\r\n\t// @param factor_self: factor to multiply force that will apply on this shape. default to 0.\r\n\t// @param factor_other: factor to multiply force that will apply on this shape. default to 1.\r\n\t// NOTE: this function assume there's collision on start, meaning first iteration of repeal will ALWAYS happen.\r\n\t// @return: total movement due to repeling (vector).\r\n\trepel: function(obj, force, iterations, factor_self, factor_other) {\r\n\t\t// set defaults\r\n\t\tforce = force || 1;\r\n\t\titerations = iterations || 1;\r\n\t\tif (factor_self === undefined) factor_self = 0;\r\n\t\tif (factor_other === undefined) factor_other = 1;\r\n\r\n\t\t// get push vectors\r\n\t\tlet push_vector_other, push_vector_self;\r\n\t\tlet push_vector = this.get_repel_direction(obj).multiply_scalar_self(force);\r\n\t\tif (factor_other) push_vector_other = push_vector.multiply_scalar(factor_other);\r\n\t\tif (factor_self) push_vector_self = push_vector.multiply_scalar(factor_self * -1);\r\n\r\n\t\t// for return value\r\n\t\tlet ret = SSCD.Vector.ZERO.clone();\r\n\r\n\t\t// now do the repeling\r\n\t\tlet collide = true;\r\n\t\twhile (collide && iterations > 0) {\r\n\t\t\t// decreate iterations count\r\n\t\t\titerations--;\r\n\r\n\t\t\t// do pushing\r\n\t\t\tif (push_vector_other) obj.move(push_vector_other);\r\n\t\t\tif (push_vector_self) this.move(push_vector_self);\r\n\t\t\tret.add_self(push_vector);\r\n\r\n\t\t\t// check if still colliding\r\n\t\t\tcollide = this.test_collide_with(obj);\r\n\t\t}\r\n\r\n\t\t// return total pushed\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// get repel direction between this shape and another shape / vector.\r\n\tget_repel_direction: function(obj) {\r\n\t\t// get the center of this object\r\n\t\tlet center = this.get_abs_center();\r\n\r\n\t\t// get center of other object / vector\r\n\t\tlet other_center;\r\n\t\tif (obj instanceof SSCD.Vector) {\r\n\t\t\tother_center = obj;\r\n\t\t} else {\r\n\t\t\tother_center = obj.get_abs_center();\r\n\t\t}\r\n\r\n\t\t// return repel direction vector\r\n\t\treturn other_center.sub(center).normalize_self();\r\n\t},\r\n\r\n\t// return shape fill color for debug rendering.\r\n\t// @param opacity - if provided, will use this opacity in return color.\r\n\t__get_render_fill_color: function(opacity) {\r\n\t\t// if have override fill color use it:\r\n\t\tif (this.__override_fill_color) {\r\n\t\t\treturn this.__override_fill_color;\r\n\t\t}\r\n\r\n\t\t// else, return color based on tag\r\n\t\treturn this.__collision_tags_to_color(this.__collision_tags_val, opacity);\r\n\t},\r\n\r\n\t// return shape stroke color for debug rendering.\r\n\t// @param opacity - if provided, will use this opacity in return color.\r\n\t__get_render_stroke_color: function(opacity) {\r\n\t\t// if have override stroke color use it:\r\n\t\tif (this.__override_stroke_color) {\r\n\t\t\treturn this.__override_stroke_color;\r\n\t\t}\r\n\r\n\t\t// else, return color based on tag\r\n\t\treturn this.__collision_tags_to_color(this.__collision_tags_val, opacity);\r\n\t},\r\n\r\n\t// set colors to override the debug rendering colors.\r\n\t// note1: values accept any html5 color value (eg \"rgba(r,g,b,a)\" or \"white\").\r\n\t// note2: set nulls to use default colors (based on shape tags).\r\n\t// @param fill_color - shape fill color in debug render.\r\n\t// @param stroke_color - shape stroke color in debug render.\r\n\tset_debug_render_colors: function(fill_color, stroke_color) {\r\n\t\tthis.__override_fill_color = fill_color;\r\n\t\tthis.__override_stroke_color = stroke_color;\r\n\t},\r\n\r\n\t// default override colors is null - don't override debug colors.\r\n\t__override_fill_color: null,\r\n\t__override_stroke_color: null,\r\n\r\n\t// return color based on collision tags\r\n\t// @param tags - list with collision tags.\r\n\t// @param opacity - output color opacity.\r\n\t__collision_tags_to_color: function(tags, opacity) {\r\n\t\tlet r = Math.round(Math.abs(Math.sin(tags)) * 255);\r\n\t\tlet g = Math.round(Math.abs(Math.cos(tags)) * 255);\r\n\t\tlet b = Math.round(r ^ g);\r\n\t\treturn \"rgba(\" + r + \",\" + g + \",\" + b + \",\" + opacity + \")\";\r\n\t},\r\n\r\n\t// attach data/object to this shape.\r\n\t// @param obj - anything you want to attach to this shape.\r\n\tset_data: function(obj) {\r\n\t\tthis.__data = obj;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// return the attached data / object of this shape.\r\n\tget_data: function() {\r\n\t\treturn this.__data;\r\n\t},\r\n\r\n\t// return shape type.\r\n\tget_name: function() {\r\n\t\treturn this.__type;\r\n\t},\r\n\r\n\t// render shape axis-aligned-bounding-box.\r\n\t// @param ctx - 2d context of a canvas.\r\n\t// @param camera_pos - optional camera position to transform the render position.\r\n\trender_aabb: function(ctx, camera_pos) {\r\n\t\tlet box = this.get_aabb();\r\n\r\n\t\t// draw the rect\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(box.position.x - camera_pos.x, box.position.y - camera_pos.y, box.size.x, box.size.y);\r\n\r\n\t\t// draw stroke\r\n\t\tctx.lineWidth = \"1\";\r\n\t\tctx.strokeStyle = 'rgba(50, 175, 45, 0.5)';\r\n\t\tctx.stroke();\r\n\t},\r\n\r\n\t// set the current position of this shape.\r\n\t// @param vector - new position.\r\n\tset_position: function(vector) {\r\n\t\tthis.__position.x = vector.x;\r\n\t\tthis.__position.y = vector.y;\r\n\t\tthis.__update_position();\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// get position (return vector).\r\n\tget_position: function() {\r\n\t\treturn this.__position.clone();\r\n\t},\r\n\r\n\t// move the shape from its current position.\r\n\t// @param vector - vector to move the shape.\r\n\tmove: function(vector) {\r\n\t\tthis.set_position(this.__position.add(vector));\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// should be called whenever position changes.\r\n\t__update_position: function() {\r\n\t\t// call position-change hook\r\n\t\tif (this.__update_position_hook) {\r\n\t\t\tthis.__update_position_hook();\r\n\t\t}\r\n\r\n\t\t// remove bounding box cache\r\n\t\tif (this.__aabb) {\r\n\t\t\tthis.__update_aabb_pos();\r\n\t\t}\r\n\r\n\t\t// update in world\r\n\t\tthis.__update_parent_world();\r\n\t},\r\n\r\n\t// called to update axis-aligned-bounding-box position.\r\n\t// this function called AFTER the position update, meaning new position applied.\r\n\t// this function only called if have aabb in cache.\r\n\t__update_aabb_pos: function() {\r\n\t\tthis.__aabb.position = this.__position;\r\n\t},\r\n\r\n\t// return the absolute center of the shape.\r\n\tget_abs_center: function() {\r\n\t\tlet aabb = this.get_aabb();\r\n\t\treturn aabb.position.add(aabb.size.multiply_scalar(0.5));\r\n\t},\r\n\r\n\t// reset bounding box.\r\n\treset_aabb: function() {\r\n\t\tthis.__aabb = undefined;\r\n\t},\r\n\r\n\t// update this shape in parent world (call this when shape change position or change and need to notify world).\r\n\t__update_parent_world: function() {\r\n\t\tif (this.__world) {\r\n\t\t\tthis.__world.__update_shape_grid(this);\r\n\t\t}\r\n\t},\r\n\r\n\t// optional hook you can override that will be called whenever shape position changes.\r\n\t__update_position_hook: null,\r\n\r\n\t// render (for debug purposes).\r\n\t// @param ctx - 2d context of a canvas.\r\n\t// @param camera_pos - optional camera position to transform the render position.\r\n\trender: function() {\r\n\t\tthrow new SSCD.NotImplementedError(\"\");\r\n\t},\r\n\r\n\t// build the shape's axis-aligned bounding box.\r\n\tbuild_aabb: function() {\r\n\t\tthrow new SSCD.NotImplementedError(\"\");\r\n\t},\r\n\r\n\t// return the axis-aligned-bounding-box of this shape.\r\n\tget_aabb: function() {\r\n\t\tthis.__aabb = this.__aabb || this.build_aabb();\r\n\t\treturn this.__aabb;\r\n\t},\r\n\r\n};\r\n","/*\r\n * a special shape made from multiple shapes combined together\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// create a composite shape\r\n// @param position - optional starting position (vector)\r\n// @param objects - optional list of collision objects to start with\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.CompositeShape = function(position, objects) {\r\n\t// call init chain\r\n\tthis.init();\r\n\tthis.__init_comp_shape(position, objects);\r\n};\r\n\r\n// composite shape prototype\r\nSSCD.CompositeShape.prototype = {\r\n\r\n\t// set type and collision type\r\n\t__type: \"composite-shape\",\r\n\t__collision_type: \"composite-shape\",\r\n\r\n\t// init the composite shape.\r\n\t// @param position - source position.\r\n\t// @param objects - list of starting objects.\r\n\t__init_comp_shape: function(position, objects) {\r\n\t\t// create empty list of shapes\r\n\t\tthis.__shapes = [];\r\n\r\n\t\t// default position\r\n\t\tposition = position || SSCD.Vector.ZERO;\r\n\t\tthis.set_position(position);\r\n\r\n\t\t// add objects if provided\r\n\t\tif (objects) {\r\n\t\t\tfor (let i = 0; i < objects.length; ++i) {\r\n\t\t\t\tthis.add(objects[i]);\r\n\t\t\t}\r\n\t\t}\r\n\t},\r\n\r\n\t// render (for debug purposes).\r\n\t// @param ctx - 2d context of a canvas.\r\n\t// @param camera_pos - optional camera position to transform the render position.\r\n\trender: function(ctx, camera_pos) {\r\n\t\t// first render all shapes\r\n\t\tfor (let i = 0; i < this.__shapes.length; ++i) {\r\n\t\t\tthis.__shapes[i].shape.render(ctx, camera_pos);\r\n\t\t}\r\n\t},\r\n\r\n\t// repeal an object from this object.\r\n\t// here we iterate over sub-object and repeal only from the ones we collide with.\r\n\t// read base shape repel() doc for more info.\r\n\trepel: function(obj, force, iterations, factor_self, factor_other) {\r\n\t\t// do repel from independant shapes inside this composite shape\r\n\t\tlet ret = SSCD.Vector.ZERO.clone();\r\n\t\tfor (let i = 0; i < this.__shapes.length; ++i) {\r\n\t\t\tlet shape = this.__shapes[i].shape;\r\n\t\t\tif (shape.test_collide_with(obj)) {\r\n\t\t\t\tret.add_self(shape.repel(obj, force, iterations, 0, factor_other));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// if have factor to move self, apply it\r\n\t\tif ((factor_self || 0) !== 0) {\r\n\t\t\tthis.move(ret.multiply_scalar(factor_self * -1));\r\n\t\t}\r\n\r\n\t\t// return factor\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// set colors to override the debug rendering colors.\r\n\t// read base shape set_debug_render_colors() doc for more info.\r\n\tset_debug_render_colors: function(fill_color, stroke_color) {\r\n\t\tthis.__override_fill_color = fill_color;\r\n\t\tthis.__override_stroke_color = stroke_color;\r\n\t\tfor (let i = 0; i < this.__shapes.length; ++i) {\r\n\t\t\tthis.__shapes[i].shape.set_debug_render_colors(fill_color, stroke_color);\r\n\t\t}\r\n\t},\r\n\r\n\t// get shapes list.\r\n\tget_shapes: function() {\r\n\t\t// if already got shapes list in cache return it\r\n\t\tif (this.__shapes_list_c) {\r\n\t\t\treturn this.__shapes_list_c;\r\n\t\t}\r\n\r\n\t\t// create shapes list\r\n\t\tlet ret = [];\r\n\t\tfor (let i = 0; i < this.__shapes.length; ++i) {\r\n\t\t\tret.push(this.__shapes[i].shape);\r\n\t\t}\r\n\r\n\t\t// add to cache and return\r\n\t\tthis.__shapes_list_c = ret;\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// return axis-aligned-bounding-box.\r\n\tbuild_aabb: function() {\r\n\t\t// if no shapes return zero aabb\r\n\t\tif (this.__shapes.length === 0) {\r\n\t\t\tthis.__aabb_pos_offset_c = SSCD.Vector.ZERO;\r\n\t\t\treturn new SSCD.AABB(SSCD.Vector.ZERO, SSCD.Vector.ZERO);\r\n\t\t}\r\n\r\n\t\t// return combined aabb\r\n\t\tlet ret = null;\r\n\t\tfor (let i = 0; i < this.__shapes.length; ++i) {\r\n\t\t\tlet curr_aabb = this.__shapes[i].shape.get_aabb();\r\n\t\t\tif (ret) {\r\n\t\t\t\tret.expand(curr_aabb);\r\n\t\t\t} else {\r\n\t\t\t\tret = curr_aabb;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// store diff between position and bounding-box position, for faster aabb movement\r\n\t\tthis.__aabb_pos_offset_c = ret.position.sub(this.__position);\r\n\r\n\t\t// return bounding-box\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// called to update axis-aligned-bounding-box position.\r\n\t__update_aabb_pos: function() {\r\n\t\tthis.__aabb.position = this.__position.add(this.__aabb_pos_offset_c);\r\n\t},\r\n\r\n\t// add shape to the composite shape.\r\n\t// @param shape - the shape to add.\r\n\tadd: function(shape) {\r\n\t\t// make sure shape don't have a collision world\r\n\t\tif (shape.__world) {\r\n\t\t\tthrow new SSCD.IllegalActionError(\"Can't add shape with collision world to a composite shape!\");\r\n\t\t}\r\n\r\n\t\t// store shape offset\r\n\t\tlet offset = shape.__position;\r\n\r\n\t\t// reset shapes list cache\r\n\t\tthis.__shapes_list_c = undefined;\r\n\r\n\t\t// add shape to list of shapes and fix position\r\n\t\tthis.__shapes.push({\r\n\t\t\tshape: shape,\r\n\t\t\toffset: offset.clone()\r\n\t\t});\r\n\t\tshape.set_position(this.__position.add(offset));\r\n\r\n\t\t// reset bounding-box and notify collision world about the change\r\n\t\tthis.reset_aabb();\r\n\t\tthis.__update_parent_world();\r\n\r\n\t\t// set shape tags to be the composite shape tags\r\n\t\tshape.__collision_tags_val = this.__collision_tags_val;\r\n\t\tshape.__collision_tags = this.__collision_tags;\r\n\r\n\t\t// set shape debug colors\r\n\t\tshape.__override_fill_color = this.__override_fill_color;\r\n\t\tshape.__override_stroke_color = this.__override_stroke_color;\r\n\r\n\t\t// return the newly added shape\r\n\t\treturn shape;\r\n\t},\r\n\r\n\t// hook to call when update tags - update all child objects with new tags.\r\n\t__update_tags_hook: function() {\r\n\t\t// update all shapes about the new tags\r\n\t\tfor (let i = 0; i < this.__shapes; ++i) {\r\n\t\t\tlet shape = this.__shapes[i].shape;\r\n\t\t\tshape.__collision_tags_val = this.__collision_tags_val;\r\n\t\t\tshape.__collision_tags = this.__collision_tags;\r\n\t\t}\r\n\t},\r\n\r\n\t// remove a shape.\r\n\tremove: function(shape) {\r\n\t\tthis.__shapes_list_c = undefined;\r\n\t\tfor (let i = 0; i < this.__shapes.length; ++i) {\r\n\t\t\tif (this.__shapes[i].shape === shape) {\r\n\t\t\t\tthis.__shapes.splice(i, 1);\r\n\t\t\t\tthis.__update_parent_world();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthrow new SSCD.IllegalActionError(\"Shape to remove is not in composite shape!\");\r\n\t},\r\n\r\n\t// on position change - update all shapes.\r\n\t__update_position_hook: function() {\r\n\t\tfor (let i = 0; i < this.__shapes.length; ++i) {\r\n\t\t\tthis.__shapes[i].shape.set_position(this.__position.add(this.__shapes[i].offset));\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// inherit from basic shape class.\r\n// this will fill the missing functions from parent, but will not replace functions existing in child.\r\nSSCD.extend(SSCD.Shape.prototype, SSCD.CompositeShape.prototype);\r\n","/*\r\n * a special shape made from multiple shapes combined together\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// create a capsule shape. implemented by a composite-shape with two circles and a rectangle.\r\n// @param position - optional starting position (vector)\r\n// @param size - size in pixels (vector)\r\n// @param standing - if true, capsule will be standing. else, will lie down. (default: true)\r\nimport {SSCD} from \"../sscdNameSpace.js\"\r\n\r\nSSCD.Capsule = function(position, size, standing) {\r\n\t// call init chain\r\n\tthis.init();\r\n\r\n\t// default standing\r\n\tif (standing === undefined) standing = true;\r\n\r\n\t// create objects\r\n\tlet objects = [];\r\n\tif (standing) {\r\n\t\tsize = size.clone();\r\n\t\tsize.y -= size.x;\r\n\t\tobjects.push(new SSCD.Rectangle(new SSCD.Vector(-size.x * 0.5, -size.y * 0.5), size));\r\n\t\tobjects.push(new SSCD.Circle(new SSCD.Vector(0, -size.y * 0.5), size.x * 0.5));\r\n\t\tobjects.push(new SSCD.Circle(new SSCD.Vector(0, size.y * 0.5), size.x * 0.5));\r\n\t} else {\r\n\t\tsize = size.clone();\r\n\t\tsize.y -= size.x;\r\n\t\tobjects.push(new SSCD.Rectangle(new SSCD.Vector(-size.y * 0.5, -size.x * 0.5), size.flip()));\r\n\t\tobjects.push(new SSCD.Circle(new SSCD.Vector(-size.y * 0.5, 0), size.x * 0.5));\r\n\t\tobjects.push(new SSCD.Circle(new SSCD.Vector(size.y * 0.5, 0), size.x * 0.5));\r\n\t}\r\n\r\n\t// init composite shape\r\n\tthis.__init_comp_shape(position, objects);\r\n};\r\n\r\n// Capsule prototype\r\nSSCD.Capsule.prototype = {\r\n\r\n\t__type: \"capsule\",\r\n\r\n};\r\n\r\n// inherit from CompositeShape class.\r\n// this will fill the missing functions from parent, but will not replace functions existing in child.\r\nSSCD.extend(SSCD.CompositeShape.prototype, SSCD.Capsule.prototype);\r\n","/*\r\n * A circle collision shape\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// define the circle shape\r\n// @param position - center position (vector)\r\n// @param radius - circle radius (integer)\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.Circle = function(position, radius) {\r\n\t// call init chain\r\n\tthis.init();\r\n\r\n\t// set radius and size\r\n\tthis.__radius = radius;\r\n\tthis.__size = new SSCD.Vector(radius, radius).multiply_scalar_self(2);\r\n\r\n\t// set starting position\r\n\tthis.set_position(position);\r\n};\r\n\r\n// Circle prototype\r\nSSCD.Circle.prototype = {\r\n\r\n\t// set type and collision type\r\n\t__type: \"circle\",\r\n\t__collision_type: \"circle\",\r\n\r\n\t// render (for debug purposes)\r\n\t// @param ctx - 2d context of a canvas\r\n\t// @param camera_pos - optional camera position to transform the render position\r\n\trender: function(ctx, camera_pos) {\r\n\t\t// apply camera on position\r\n\t\tlet position = this.__position.sub(camera_pos);\r\n\r\n\t\t// draw the circle\r\n\t\tctx.beginPath();\r\n\t\tctx.arc(position.x, position.y, this.__radius, 0, 2 * Math.PI, false);\r\n\r\n\t\t// draw stroke\r\n\t\tctx.lineWidth = \"7\";\r\n\t\tctx.strokeStyle = this.__get_render_stroke_color(0.75);\r\n\t\tctx.stroke();\r\n\r\n\t\t// draw fill\r\n\t\tctx.fillStyle = this.__get_render_fill_color(0.35);\r\n\t\tctx.fill();\r\n\t},\r\n\r\n\t// return circle radius\r\n\tget_radius: function() {\r\n\t\treturn this.__radius;\r\n\t},\r\n\r\n\t// called to update axis-aligned-bounding-box position\r\n\t__update_aabb_pos: function() {\r\n\t\tthis.__aabb.position = this.__position.sub_scalar(this.__radius);\r\n\t},\r\n\r\n\t// return axis-aligned-bounding-box\r\n\tbuild_aabb: function() {\r\n\t\treturn new SSCD.AABB(this.__position.sub_scalar(this.__radius), this.__size);\r\n\t},\r\n\r\n\t// return the absolute center of the shape\r\n\tget_abs_center: function() {\r\n\t\treturn this.__position.clone();\r\n\t},\r\n\r\n};\r\n\r\n// inherit from basic shape class.\r\n// this will fill the missing functions from parent, but will not replace functions existing in child.\r\nSSCD.extend(SSCD.Shape.prototype, SSCD.Circle.prototype);\r\n","/*\r\n * A line collision shape\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// define the line shape\r\n// @param source - starting position (vector)\r\n// @param dest - destination point from source (vector)\r\n// output line will be from source to dest, and when you move it you will actually move the source position.\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.Line = function(source, dest) {\r\n\t// call init chain\r\n\tthis.init();\r\n\r\n\t// set dest position\r\n\tthis.__dest = dest;\r\n\r\n\t// set starting position\r\n\tthis.set_position(source);\r\n};\r\n\r\n// Line prototype\r\nSSCD.Line.prototype = {\r\n\r\n\t// set type and collision type\r\n\t__type: \"line\",\r\n\t__collision_type: \"line\",\r\n\r\n\t// render (for debug purposes)\r\n\t// @param ctx - 2d context of a canvas\r\n\t// @param camera_pos - optional camera position to transform the render position\r\n\trender: function(ctx) {\r\n\r\n\t\t// draw the line\r\n\t\tctx.beginPath();\r\n\t\tctx.moveTo(this.__position.x, this.__position.y);\r\n\t\tlet dest = this.__position.add(this.__dest);\r\n\t\tctx.lineTo(dest.x, dest.y);\r\n\r\n\t\t// draw stroke\r\n\t\tctx.lineWidth = \"7\";\r\n\t\tctx.strokeStyle = this.__get_render_stroke_color(0.75);\r\n\t\tctx.stroke();\r\n\r\n\t},\r\n\r\n\t// return axis-aligned-bounding-box\r\n\tbuild_aabb: function() {\r\n\t\tlet pos = new SSCD.Vector(0, 0);\r\n\t\tpos.x = this.__dest.x > 0 ? this.__position.x : this.__position.x + this.__dest.x;\r\n\t\tpos.y = this.__dest.y > 0 ? this.__position.y : this.__position.y + this.__dest.y;\r\n\t\tlet size = this.__dest.apply(Math.abs);\r\n\t\treturn new SSCD.AABB(pos, size);\r\n\t},\r\n\r\n\t// return absolute first point\r\n\tget_p1: function() {\r\n\t\tthis.__p1_c = this.__p1_c || this.__position.clone();\r\n\t\treturn this.__p1_c;\r\n\t},\r\n\r\n\t// return absolute second point\r\n\tget_p2: function() {\r\n\t\tthis.__p2_c = this.__p2_c || this.__position.add(this.__dest);\r\n\t\treturn this.__p2_c;\r\n\t},\r\n\r\n\t// on position change\r\n\t__update_position_hook: function() {\r\n\t\t// clear points cache\r\n\t\tthis.__p1_c = undefined;\r\n\t\tthis.__p2_c = undefined;\r\n\t},\r\n\r\n};\r\n\r\n// inherit from basic shape class.\r\n// this will fill the missing functions from parent, but will not replace functions existing in child.\r\nSSCD.extend(SSCD.Shape.prototype, SSCD.Line.prototype);\r\n","/*\r\n * A strip-of-lines collision shape\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// define the line shape\r\n// @param position - starting position (vector)\r\n// @param points - list of vectors that will make the lines.\r\n// @param closed - if true, will create a line between last and first points. default to false.\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.LineStrip = function(position, points, closed) {\r\n\t// call init chain\r\n\tthis.init();\r\n\r\n\t// set points\r\n\tthis.__points = points;\r\n\r\n\t// if not enough points assert\r\n\tif (points.length <= 1) {\r\n\t\tthrow new SSCD.IllegalActionError(\"Not enough vectors for LineStrip (got to have at least two vectors)\");\r\n\t}\r\n\r\n\t// close shape\r\n\tif (closed) {\r\n\t\tthis.__points.push(this.__points[0]);\r\n\t}\r\n\r\n\t// set starting position\r\n\tthis.set_position(position);\r\n};\r\n\r\n// line-strip prototype\r\nSSCD.LineStrip.prototype = {\r\n\r\n\t// set type and collision type\r\n\t__type: \"line-strip\",\r\n\t__collision_type: \"line-strip\",\r\n\r\n\t// render (for debug purposes)\r\n\t// @param ctx - 2d context of a canvas\r\n\t// @param camera_pos - optional camera position to transform the render position\r\n\trender: function(ctx) {\r\n\r\n\t\t// draw the lines\r\n\t\tlet to = undefined;\r\n\t\tctx.beginPath();\r\n\t\tfor (let i = 0; i < this.__points.length - 1; ++i) {\r\n\t\t\tlet from = this.__position.add(this.__points[i]);\r\n\t\t\tto = this.__position.add(this.__points[i + 1]);\r\n\t\t\tctx.moveTo(from.x, from.y);\r\n\t\t\tctx.lineTo(to.x, to.y);\r\n\t\t}\r\n\r\n\t\t// add last point\r\n\t\tctx.moveTo(to.x, to.y);\r\n\t\tto = this.__position.add(this.__points[this.__points.length - 1]);\r\n\t\tctx.lineTo(to.x, to.y);\r\n\r\n\t\t// draw stroke\r\n\t\tctx.lineWidth = \"7\";\r\n\t\tctx.strokeStyle = this.__get_render_stroke_color(0.75);\r\n\t\tctx.stroke();\r\n\r\n\t},\r\n\r\n\t// return line list with absolute positions\r\n\tget_abs_lines: function() {\r\n\t\t// if got lines in cache return it\r\n\t\tif (this.__abs_lines_c) {\r\n\t\t\treturn this.__abs_lines_c;\r\n\t\t}\r\n\r\n\t\t// create list of lines\r\n\t\tlet points = this.get_abs_points();\r\n\t\tlet ret = [];\r\n\t\tfor (let i = 0; i < points.length - 1; i++) {\r\n\t\t\tret.push([points[i], points[i + 1]]);\r\n\t\t}\r\n\r\n\t\t// add to cache and return\r\n\t\tthis.__abs_lines_c = ret;\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// return points with absolute position\r\n\tget_abs_points: function() {\r\n\t\t// if got points in cache return it\r\n\t\tif (this.__abs_points_c) {\r\n\t\t\treturn this.__abs_points_c;\r\n\t\t}\r\n\r\n\t\t// convert points\r\n\t\tlet ret = [];\r\n\t\tfor (let i = 0; i < this.__points.length; i++) {\r\n\t\t\tret.push(this.__points[i].add(this.__position));\r\n\t\t}\r\n\r\n\t\t// add to cache and return\r\n\t\tthis.__abs_points_c = ret;\r\n\t\treturn ret;\r\n\t},\r\n\r\n\t// on position change\r\n\t__update_position_hook: function() {\r\n\t\t// clear points and lines cache\r\n\t\tthis.__abs_points_c = undefined;\r\n\t\tthis.__abs_lines_c = undefined;\r\n\t},\r\n\r\n\t// called to update axis-aligned-bounding-box position\r\n\t__update_aabb_pos: function() {\r\n\t\tthis.__aabb.position.set(this.__aabb_offset_c.add(this.__position));\r\n\t},\r\n\r\n\t// return axis-aligned-bounding-box\r\n\tbuild_aabb: function() {\r\n\t\tlet ret = new SSCD.AABB(SSCD.Vector.ZERO, SSCD.Vector.ZERO);\r\n\t\tfor (let i = 0; i < this.__points.length; ++i) {\r\n\t\t\tret.add_vector(this.__points[i]);\r\n\t\t}\r\n\t\tthis.__aabb_offset_c = ret.position.clone();\r\n\t\tret.position.add_self(this.__position);\r\n\t\treturn ret;\r\n\t},\r\n\r\n};\r\n\r\n// inherit from basic shape class.\r\n// this will fill the missing functions from parent, but will not replace functions existing in child.\r\nSSCD.extend(SSCD.Shape.prototype, SSCD.LineStrip.prototype);\r\n","/*\r\n * rectangle collision shape\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// define the rectangle shape\r\n// @param position - starting position (vector)\r\n// @param size - rectangle size (vector)\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.Rectangle = function(position, size) {\r\n\t// call init chain\r\n\tthis.init();\r\n\r\n\t// set radius and size\r\n\tthis.__size = size;\r\n\r\n\t// set starting position\r\n\tthis.set_position(position);\r\n};\r\n\r\n// rectangle prototype\r\nSSCD.Rectangle.prototype = {\r\n\r\n\t// set type and collision type\r\n\t__type: \"rectangle\",\r\n\t__collision_type: \"rectangle\",\r\n\r\n\t// render (for debug purposes)\r\n\t// @param ctx - 2d context of a canvas\r\n\t// @param camera_pos - optional camera position to transform the render position\r\n\trender: function(ctx, camera_pos) {\r\n\t\t// apply camera on position\r\n\t\tlet position = this.__position.sub(camera_pos);\r\n\r\n\t\t// draw the rect\r\n\t\tctx.beginPath();\r\n\t\tctx.rect(position.x, position.y, this.__size.x, this.__size.y);\r\n\r\n\t\t// draw stroke\r\n\t\tctx.lineWidth = \"7\";\r\n\t\tctx.strokeStyle = this.__get_render_stroke_color(0.75);\r\n\t\tctx.stroke();\r\n\r\n\t\t// draw fill\r\n\t\tctx.fillStyle = this.__get_render_fill_color(0.35);\r\n\t\tctx.fill();\r\n\t},\r\n\r\n\t// return rectangle size\r\n\tget_size: function() {\r\n\t\treturn this.__size.clone();\r\n\t},\r\n\r\n\t// return axis-aligned-bounding-box\r\n\tbuild_aabb: function() {\r\n\t\treturn new SSCD.AABB(this.__position, this.__size);\r\n\t},\r\n\r\n\t// return absolute top-left corner\r\n\tget_top_left: function() {\r\n\t\tthis.__top_left_c = this.__top_left_c || this.__position.clone();\r\n\t\treturn this.__top_left_c;\r\n\t},\r\n\r\n\t// return absolute bottom-left corner\r\n\tget_bottom_left: function() {\r\n\t\tthis.__bottom_left_c = this.__bottom_left_c || this.__position.add(new SSCD.Vector(0, this.__size.y));\r\n\t\treturn this.__bottom_left_c;\r\n\t},\r\n\r\n\t// return absolute top-right corner\r\n\tget_top_right: function() {\r\n\t\tthis.__top_right_c = this.__top_right_c || this.__position.add(new SSCD.Vector(this.__size.x, 0));\r\n\t\treturn this.__top_right_c;\r\n\t},\r\n\r\n\t// return absolute bottom-right corner\r\n\tget_bottom_right: function() {\r\n\t\tthis.__bottom_right_c = this.__bottom_right_c || this.__position.add(new SSCD.Vector(this.__size.x, this.__size.y));\r\n\t\treturn this.__bottom_right_c;\r\n\t},\r\n\r\n\t// return absolute center\r\n\tget_abs_center: function() {\r\n\t\tthis.__abs_center_c = this.__abs_center_c || this.__position.add(this.__size.divide_scalar(2));\r\n\t\treturn this.__abs_center_c;\r\n\t},\r\n\r\n\t// on position change\r\n\t__update_position_hook: function() {\r\n\t\t// clear corner cache\r\n\t\tthis.__top_left_c = undefined;\r\n\t\tthis.__top_right_c = undefined;\r\n\t\tthis.__bottom_left_c = undefined;\r\n\t\tthis.__bottom_right_c = undefined;\r\n\t\tthis.__abs_center_c = undefined;\r\n\t},\r\n\r\n};\r\n\r\n// inherit from basic shape class.\r\n// this will fill the missing functions from parent, but will not replace functions existing in child.\r\nSSCD.extend(SSCD.Shape.prototype, SSCD.Rectangle.prototype);\r\n","/*\r\n * here we define all the collision-detection functions for all possible shape combinations\r\n * Author: Ronen Ness, 2015\r\n */\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.CollisionManager = {\r\n\r\n\t// test collision between two objects, a and b.\r\n\t// @param a, b - instances to check collision. can be any shape or vector.\r\n\ttest_collision: function(a, b) {\r\n\t\t// vector-vector collision\r\n\t\tif (a instanceof SSCD.Vector && b instanceof SSCD.Vector) {\r\n\t\t\treturn this._test_collision_vector_vector(a, b);\r\n\t\t}\r\n\r\n\t\t// composite shape collision\r\n\t\tif (a.__collision_type == \"composite-shape\") {\r\n\t\t\treturn this._test_collision_composite_shape(a, b);\r\n\t\t}\r\n\t\tif (b.__collision_type == \"composite-shape\") {\r\n\t\t\treturn this._test_collision_composite_shape(b, a);\r\n\t\t}\r\n\r\n\t\t// circle-vector collision\r\n\t\tif (a instanceof SSCD.Vector && b.__collision_type == \"circle\") {\r\n\t\t\treturn this._test_collision_circle_vector(b, a);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"circle\" && b instanceof SSCD.Vector) {\r\n\t\t\treturn this._test_collision_circle_vector(a, b);\r\n\t\t}\r\n\r\n\t\t// circle-circle collision\r\n\t\tif (a.__collision_type == \"circle\" && b.__collision_type == \"circle\") {\r\n\t\t\treturn this._test_collision_circle_circle(b, a);\r\n\t\t}\r\n\r\n\t\t// circle-rectangle collision\r\n\t\tif (a.__collision_type == \"circle\" && b.__collision_type == \"rectangle\") {\r\n\t\t\treturn this._test_collision_circle_rect(a, b);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"rectangle\" && b.__collision_type == \"circle\") {\r\n\t\t\treturn this._test_collision_circle_rect(b, a);\r\n\t\t}\r\n\r\n\t\t// circle-line collision\r\n\t\tif (a.__collision_type == \"circle\" && b.__collision_type == \"line\") {\r\n\t\t\treturn this._test_collision_circle_line(a, b);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"line\" && b.__collision_type == \"circle\") {\r\n\t\t\treturn this._test_collision_circle_line(b, a);\r\n\t\t}\r\n\r\n\t\t// linestrip-line collision\r\n\t\tif (a.__collision_type == \"line-strip\" && b.__collision_type == \"line\") {\r\n\t\t\treturn this._test_collision_linestrip_line(a, b);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"line\" && b.__collision_type == \"line-strip\") {\r\n\t\t\treturn this._test_collision_linestrip_line(b, a);\r\n\t\t}\r\n\r\n\t\t// circle-linestrip collision\r\n\t\tif (a.__collision_type == \"circle\" && b.__collision_type == \"line-strip\") {\r\n\t\t\treturn this._test_collision_circle_linestrip(a, b);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"line-strip\" && b.__collision_type == \"circle\") {\r\n\t\t\treturn this._test_collision_circle_linestrip(b, a);\r\n\t\t}\r\n\r\n\t\t// rect-vector collision\r\n\t\tif (a instanceof SSCD.Vector && b.__collision_type == \"rectangle\") {\r\n\t\t\treturn this._test_collision_rect_vector(b, a);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"rectangle\" && b instanceof SSCD.Vector) {\r\n\t\t\treturn this._test_collision_rect_vector(a, b);\r\n\t\t}\r\n\r\n\t\t// rect-rect collision\r\n\t\tif (a.__collision_type == \"rectangle\" && b.__collision_type == \"rectangle\") {\r\n\t\t\treturn this._test_collision_rect_rect(b, a);\r\n\t\t}\r\n\r\n\t\t// line-strip with line-strip collision\r\n\t\tif (a.__collision_type == \"line-strip\" && b.__collision_type == \"line-strip\") {\r\n\t\t\treturn this._test_collision_linestrip_linestrip(a, b);\r\n\t\t}\r\n\r\n\t\t// rect-line collision\r\n\t\tif (a.__collision_type == \"line\" && b.__collision_type == \"rectangle\") {\r\n\t\t\treturn this._test_collision_rect_line(b, a);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"rectangle\" && b.__collision_type == \"line\") {\r\n\t\t\treturn this._test_collision_rect_line(a, b);\r\n\t\t}\r\n\r\n\t\t// rect-linestrip collision\r\n\t\tif (a.__collision_type == \"line-strip\" && b.__collision_type == \"rectangle\") {\r\n\t\t\treturn this._test_collision_rect_linestrip(b, a);\r\n\t\t}\r\n\t\tif (a.__collision_type == \"rectangle\" && b.__collision_type == \"line-strip\") {\r\n\t\t\treturn this._test_collision_rect_linestrip(a, b);\r\n\t\t}\r\n\r\n\t\t// line-line collision\r\n\t\tif (a.__collision_type == \"line\" && b.__collision_type == \"line\") {\r\n\t\t\treturn this._test_collision_line_line(a, b);\r\n\t\t}\r\n\r\n\t\t// vector-line collision\r\n\t\tif (a.__collision_type == \"line\" && b instanceof SSCD.Vector) {\r\n\t\t\treturn this._test_collision_vector_line(b, a);\r\n\t\t}\r\n\t\tif (a instanceof SSCD.Vector && b.__collision_type == \"line\") {\r\n\t\t\treturn this._test_collision_vector_line(a, b);\r\n\t\t}\r\n\r\n\t\t// vector-linestrip collision\r\n\t\tif (a.__collision_type == \"line-strip\" && b instanceof SSCD.Vector) {\r\n\t\t\treturn this._test_collision_vector_linestrip(b, a);\r\n\t\t}\r\n\t\tif (a instanceof SSCD.Vector && b.__collision_type == \"line-strip\") {\r\n\t\t\treturn this._test_collision_vector_linestrip(a, b);\r\n\t\t}\r\n\r\n\t\t// unsupported shapes!\r\n\t\tthrow new SSCD.UnsupportedShapes(a, b);\r\n\t},\r\n\r\n\t// test collision between two vectors\r\n\t_test_collision_vector_vector: function(a, b) {\r\n\t\treturn (a.x === b.x) && (a.y === b.y);\r\n\t},\r\n\r\n\t// test collision between circle and vector\r\n\t_test_collision_circle_vector: function(circle, vector) {\r\n\t\treturn SSCD.Math.distance(circle.__position, vector) <= circle.__radius;\r\n\t},\r\n\r\n\t// test collision between circle and another circle\r\n\t_test_collision_circle_circle: function(a, b) {\r\n\t\treturn SSCD.Math.distance(a.__position, b.__position) <= a.__radius + b.__radius;\r\n\t},\r\n\r\n\t// test collision between rectangle and vector\r\n\t_test_collision_rect_vector: function(rect, vector) {\r\n\t\treturn (vector.x >= rect.__position.x) && (vector.y >= rect.__position.y) &&\r\n\t\t\t(vector.x <= rect.__position.x + rect.__size.x) &&\r\n\t\t\t(vector.y <= rect.__position.y + rect.__size.y);\r\n\t},\r\n\r\n\t// test collision vector with line\r\n\t_test_collision_vector_line: function(v, line) {\r\n\t\treturn SSCD.Math.is_on_line(v, line.get_p1(), line.get_p2());\r\n\t},\r\n\r\n\t// test collision vector with linestrip\r\n\t_test_collision_vector_linestrip: function(v, linestrip) {\r\n\t\tlet lines = linestrip.get_abs_lines();\r\n\t\tfor (let i = 0; i < lines.length; ++i) {\r\n\t\t\tif (SSCD.Math.is_on_line(v, lines[i][0], lines[i][1])) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// test collision between circle and line\r\n\t_test_collision_circle_line: function(circle, line) {\r\n\t\treturn SSCD.Math.distance_to_line(circle.__position, line.get_p1(), line.get_p2()) <= circle.__radius;\r\n\t},\r\n\r\n\t// test collision between circle and line-strip\r\n\t_test_collision_circle_linestrip: function(circle, linestrip) {\r\n\t\tlet lines = linestrip.get_abs_lines();\r\n\t\tfor (let i = 0; i < lines.length; ++i) {\r\n\t\t\tif (SSCD.Math.distance_to_line(circle.__position, lines[i][0], lines[i][1]) <= circle.__radius) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// test collision between linestrip and a single line\r\n\t_test_collision_linestrip_line: function(linestrip, line) {\r\n\t\tlet lines = linestrip.get_abs_lines();\r\n\t\tlet p1 = line.get_p1(),\r\n\t\t\tp2 = line.get_p2();\r\n\t\tfor (let i = 0; i < lines.length; ++i) {\r\n\t\t\tif (SSCD.Math.line_intersects(p1, p2, lines[i][0], lines[i][1])) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// check collision line with line\r\n\t_test_collision_line_line: function(a, b) {\r\n\t\treturn SSCD.Math.line_intersects(a.get_p1(), a.get_p2(),\r\n\t\t\tb.get_p1(), b.get_p2());\r\n\t},\r\n\r\n\t// check collision between rectangle and line\r\n\t_test_collision_rect_line: function(rect, line) {\r\n\t\t// get the line's two points\r\n\t\tlet p1 = line.get_p1();\r\n\t\tlet p2 = line.get_p2();\r\n\r\n\t\t// first check if one of the line points is contained inside the rectangle\r\n\t\tif (SSCD.CollisionManager._test_collision_rect_vector(rect, p1) ||\r\n\t\t\tSSCD.CollisionManager._test_collision_rect_vector(rect, p2)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// now check collision between line and rect lines\r\n\r\n\t\t// left side\r\n\t\tlet r1 = rect.get_top_left();\r\n\t\tlet r2 = rect.get_bottom_left();\r\n\t\tif (SSCD.Math.line_intersects(p1, p2, r1, r2)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// right side\r\n\t\tlet r3 = rect.get_top_right();\r\n\t\tlet r4 = rect.get_bottom_right();\r\n\t\tif (SSCD.Math.line_intersects(p1, p2, r3, r4)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// top side\r\n\t\tif (SSCD.Math.line_intersects(p1, p2, r1, r3)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// bottom side\r\n\t\tif (SSCD.Math.line_intersects(p1, p2, r2, r4)) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// no collision\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// test collision between rectagnle and linesstrip\r\n\t_test_collision_rect_linestrip: function(rect, linesstrip) {\r\n\t\t// first check all points\r\n\t\tlet points = linesstrip.get_abs_points();\r\n\t\tfor (let i = 0; i < points.length; ++i) {\r\n\t\t\tif (this._test_collision_rect_vector(rect, points[i])) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// now check intersection with rectangle sides\r\n\r\n\t\tlet r1 = rect.get_top_left();\r\n\t\tlet r2 = rect.get_bottom_left();\r\n\t\tlet r3 = rect.get_top_right();\r\n\t\tlet r4 = rect.get_bottom_right();\r\n\r\n\t\tlet lines = linesstrip.get_abs_lines();\r\n\t\tfor (let i = 0; i < lines.length; ++i) {\r\n\t\t\tlet p1 = lines[i][0];\r\n\t\t\tlet p2 = lines[i][1];\r\n\r\n\t\t\t// left side\r\n\t\t\tif (SSCD.Math.line_intersects(p1, p2, r1, r2)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// right side\r\n\t\t\tif (SSCD.Math.line_intersects(p1, p2, r3, r4)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// top side\r\n\t\t\tif (SSCD.Math.line_intersects(p1, p2, r1, r3)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\r\n\t\t\t// bottom side\r\n\t\t\tif (SSCD.Math.line_intersects(p1, p2, r2, r4)) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// no collision\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// test collision between two linestrips\r\n\t_test_collision_linestrip_linestrip: function(strip1, strip2) {\r\n\t\tlet lines1 = strip1.get_abs_lines();\r\n\t\tlet lines2 = strip2.get_abs_lines();\r\n\t\tfor (let i = 0; i < lines1.length; ++i) {\r\n\t\t\tfor (let j = 0; j < lines2.length; ++j) {\r\n\t\t\t\tif (SSCD.Math.line_intersects(lines1[i][0], lines1[i][1],\r\n\t\t\t\t\t\tlines2[j][0], lines2[j][1])) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// test composite shape with any other shape\r\n\t_test_collision_composite_shape: function(composite, other) {\r\n\t\t// get all shapes in composite shape\r\n\t\tlet comp_shapes = composite.get_shapes();\r\n\r\n\t\t// special case: other shape is a composite shape as well\r\n\t\tif (other.__collision_type == \"composite-shape\") {\r\n\t\t\tlet other_shapes = other.get_shapes();\r\n\t\t\tfor (let i = 0; i < comp_shapes.length; ++i) {\r\n\t\t\t\tfor (let j = 0; j < other_shapes.length; ++j) {\r\n\t\t\t\t\tif (SSCD.CollisionManager.test_collision(comp_shapes[i], other_shapes[j])) {\r\n\t\t\t\t\t\treturn true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t// normal case - other shape is a normal shape\r\n\t\telse {\r\n\t\t\tfor (let i = 0; i < comp_shapes.length; ++i) {\r\n\t\t\t\tif (SSCD.CollisionManager.test_collision(comp_shapes[i], other)) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// no collision found\r\n\t\treturn false;\r\n\r\n\t},\r\n\r\n\t// test collision between circle and rectangle\r\n\t_test_collision_circle_rect: function(circle, rect) {\r\n\t\t// get circle center\r\n\t\tlet circle_pos = circle.__position;\r\n\r\n\t\t// first check if circle center is inside the rectangle - easy case\r\n\t\tlet collide = SSCD.CollisionManager._test_collision_rect_vector(rect, circle_pos);\r\n\t\tif (collide) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// get rectangle center\r\n\t\tlet rect_center = rect.get_abs_center();\r\n\r\n\t\t// now check other simple case - collision between rect center and circle\r\n\t\tcollide = SSCD.CollisionManager._test_collision_circle_vector(circle, rect_center);\r\n\t\tif (collide) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\t// create a list of lines to check (in the rectangle) based on circle position to rect center\r\n\t\tlet lines = [];\r\n\t\tif (rect_center.x > circle_pos.x) {\r\n\t\t\tlines.push([rect.get_top_left(), rect.get_bottom_left()]);\r\n\t\t} else {\r\n\t\t\tlines.push([rect.get_top_right(), rect.get_bottom_right()]);\r\n\t\t}\r\n\t\tif (rect_center.y > circle_pos.y) {\r\n\t\t\tlines.push([rect.get_top_left(), rect.get_top_right()]);\r\n\t\t} else {\r\n\t\t\tlines.push([rect.get_bottom_left(), rect.get_bottom_right()]);\r\n\t\t}\r\n\r\n\t\t// now check intersection between circle and each of the rectangle lines\r\n\t\tfor (let i = 0; i < lines.length; ++i) {\r\n\t\t\tlet dist_to_line = SSCD.Math.distance_to_line(circle_pos, lines[i][0], lines[i][1]);\r\n\t\t\tif (dist_to_line <= circle.__radius) {\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// no collision..\r\n\t\treturn false;\r\n\t},\r\n\r\n\t// test collision between circle and rectangle\r\n\t_test_collision_rect_rect: function(a, b) {\r\n\t\tlet r1 = {\r\n\t\t\tleft: a.__position.x,\r\n\t\t\tright: a.__position.x + a.__size.x,\r\n\t\t\ttop: a.__position.y,\r\n\t\t\tbottom: a.__position.y + a.__size.y\r\n\t\t};\r\n\t\tlet r2 = {\r\n\t\t\tleft: b.__position.x,\r\n\t\t\tright: b.__position.x + b.__size.x,\r\n\t\t\ttop: b.__position.y,\r\n\t\t\tbottom: b.__position.y + b.__size.y\r\n\t\t};\r\n\t\treturn !(r2.left > r1.right ||\r\n\t\t\tr2.right < r1.left ||\r\n\t\t\tr2.top > r1.bottom ||\r\n\t\t\tr2.bottom < r1.top);\r\n\t},\r\n};\r\n\r\n// exception when trying to check collision on shapes not supported\r\nSSCD.UnsupportedShapes = function(a, b) {\r\n\tthis.name = \"Unsupported Shapes\";\r\n\tthis.message = \"Unsupported shapes collision test! '\" + a.get_name() + \"' <-> '\" + b.get_name() + \"'.\";\r\n};\r\nSSCD.UnsupportedShapes.prototype = Error.prototype;\r\n","/*\r\n * Define axis-aligned-bounding-box class.\r\n * Author: Ronen Ness, 2015\r\n */\r\n\r\n// Axis-aligned-bounding-box class\r\n// position: top-left corner (vector)\r\n// size: width and height (vector)\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\nSSCD.AABB = function(position, size) {\r\n\tthis.position = position.clone();\r\n\tthis.size = size.clone();\r\n};\r\n\r\n// some aabb methods\r\nSSCD.AABB.prototype = {\r\n\r\n\t// expand this bounding-box by other bounding box\r\n\texpand: function(other) {\r\n\t\t// get new bounds\r\n\t\tlet min_x = Math.min(this.position.x, other.position.x);\r\n\t\tlet min_y = Math.min(this.position.y, other.position.y);\r\n\t\tlet max_x = Math.max(this.position.x + this.size.x, other.position.x + other.size.x);\r\n\t\tlet max_y = Math.max(this.position.y + this.size.y, other.position.y + other.size.y);\r\n\r\n\t\t// set them\r\n\t\tthis.position.x = min_x;\r\n\t\tthis.position.y = min_y;\r\n\t\tthis.size.x = max_x - min_x;\r\n\t\tthis.size.y = max_y - min_y;\r\n\t},\r\n\r\n\t// expand this bounding-box with vector\r\n\tadd_vector: function(vector) {\r\n\t\t// update position x\r\n\t\tlet push_pos_x = this.position.x - vector.x;\r\n\t\tif (push_pos_x > 0) {\r\n\t\t\tthis.position.x -= push_pos_x;\r\n\t\t\tthis.size.x += push_pos_x;\r\n\t\t}\r\n\r\n\t\t// update position y\r\n\t\tlet push_pos_y = this.position.y - vector.y;\r\n\t\tif (push_pos_y > 0) {\r\n\t\t\tthis.position.y -= push_pos_y;\r\n\t\t\tthis.size.y += push_pos_y;\r\n\t\t}\r\n\r\n\t\t// update size x\r\n\t\tlet push_size_x = vector.x - (this.position.x + this.size.x);\r\n\t\tif (push_size_x > 0) {\r\n\t\t\tthis.size.x += push_size_x;\r\n\t\t}\r\n\r\n\t\t// update size y\r\n\t\tlet push_size_y = vector.y - (this.position.y + this.size.y);\r\n\t\tif (push_size_y > 0) {\r\n\t\t\tthis.size.y += push_size_y;\r\n\t\t}\r\n\t},\r\n\r\n\t// clone this aabb\r\n\tclone: function() {\r\n\t\treturn new SSCD.AABB(this.position, this.size);\r\n\t}\r\n\r\n};\r\n","/*\r\n * Some useful Math functions.\r\n * Author: Ronen Ness, 2015\r\n */\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\n// set namespace\r\nSSCD.Math = {};\r\n\r\n// Converts from degrees to radians.\r\nSSCD.Math.to_radians = function(degrees) {\r\n\treturn degrees * Math.PI / 180;\r\n};\r\n\r\n// Converts from radians to degrees.\r\nSSCD.Math.to_degrees = function(radians) {\r\n\treturn radians * 180 / Math.PI;\r\n};\r\n\r\n// get distance between vectors\r\nSSCD.Math.distance = function(p1, p2) {\r\n\tlet dx = p2.x - p1.x,\r\n\t\tdy = p2.y - p1.y;\r\n\treturn Math.sqrt(dx * dx + dy * dy);\r\n};\r\n\r\n// get distance without sqrt\r\nSSCD.Math.dist2 = function(p1, p2) {\r\n\tlet dx = p2.x - p1.x,\r\n\t\tdy = p2.y - p1.y;\r\n\treturn (dx * dx + dy * dy);\r\n};\r\n\r\n// angle between two vectors\r\nSSCD.Math.angle = function(P1, P2) {\r\n\tlet deltaY = P2.y - P1.y,\r\n\t\tdeltaX = P2.x - P1.x;\r\n\r\n\treturn Math.atan2(deltaY, deltaX) * 180 / Math.PI;\r\n};\r\n\r\n// distance from point to line\r\n// p is point to check\r\n// v and w are the two edges of the line segment\r\nSSCD.Math.distance_to_line = function(p, v, w) {\r\n\r\n\tlet l2 = SSCD.Math.dist2(v, w);\r\n\tlet t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;\r\n\tif (t < 0) {\r\n\t\treturn SSCD.Math.distance(p, v);\r\n\t}\r\n\tif (t > 1) {\r\n\t\treturn SSCD.Math.distance(p, w);\r\n\t}\r\n\treturn SSCD.Math.distance(p, {\r\n\t\tx: v.x + t * (w.x - v.x),\r\n\t\ty: v.y + t * (w.y - v.y)\r\n\t});\r\n};\r\n\r\n// Adapted from: http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect/1968345#1968345\r\n// check if two lines intersect\r\nSSCD.Math.line_intersects = function(p0, p1, p2, p3) {\r\n\r\n\tlet s1_x, s1_y, s2_x, s2_y;\r\n\ts1_x = p1.x - p0.x;\r\n\ts1_y = p1.y - p0.y;\r\n\ts2_x = p3.x - p2.x;\r\n\ts2_y = p3.y - p2.y;\r\n\r\n\tlet s, t;\r\n\ts = (-s1_y * (p0.x - p2.x) + s1_x * (p0.y - p2.y)) / (-s2_x * s1_y + s1_x * s2_y);\r\n\tt = (s2_x * (p0.y - p2.y) - s2_y * (p0.x - p2.x)) / (-s2_x * s1_y + s1_x * s2_y);\r\n\r\n\tif (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\r\n\t\t// Collision detected\r\n\t\treturn 1;\r\n\t}\r\n\r\n\treturn 0; // No collision\r\n};\r\n\r\n// return if point is on given line\r\nSSCD.Math.is_on_line = function(v, l1, l2) {\r\n\treturn SSCD.Math.distance_to_line(v, l1, l2) <= 5;\r\n};\r\n\r\n\r\n// return shortest, positive distance between two given angles.\r\n// for example:\r\n//  50, 100 will return 50\r\n//  350, 10 will return 20\r\n// angles shoule be in 0-360 values (but negatives and >360 allowed as well)\r\nSSCD.Math.angles_dis = function(a0, a1) {\r\n\r\n\t// convert to radians\r\n\ta0 = SSCD.Math.to_radians(a0);\r\n\ta1 = SSCD.Math.to_radians(a1);\r\n\r\n\t// get distance\r\n\tlet max = Math.PI * 2;\r\n\tlet da = (a1 - a0) % max;\r\n\tlet distance = 2 * da % max - da;\r\n\r\n\t// convert back to degrees\r\n\tdistance = SSCD.Math.to_degrees(distance);\r\n\r\n\t// return abs value\r\n\treturn Math.abs(distance);\r\n};\r\n","/*\r\n * This file define the 2d vector class & utils.\r\n * Author: Ronen Ness, 2015\r\n */\r\nimport {SSCD} from \"../sscdNameSpace\"\r\n\r\n// a 2d vector\r\nSSCD.Vector = function(x, y) {\r\n\tthis.x = x;\r\n\tthis.y = y;\r\n};\r\n\r\n\r\n// set vector functions\r\nSSCD.Vector.prototype = {\r\n\r\n\t// for debug and prints\r\n\tget_name: function() {\r\n\t\treturn \"vector\";\r\n\t},\r\n\r\n\t// clone vector\r\n\tclone: function() {\r\n\t\treturn new SSCD.Vector(this.x, this.y);\r\n\t},\r\n\r\n\t// set value from another vector\r\n\tset: function(vector) {\r\n\t\tthis.x = vector.x;\r\n\t\tthis.y = vector.y;\r\n\t},\r\n\r\n\t// flip between x and y (return without changing self)\r\n\tflip: function() {\r\n\t\treturn new SSCD.Vector(this.y, this.x);\r\n\t},\r\n\r\n\t// flip between x and y (change self values)\r\n\tflip_self: function() {\r\n\t\tthis.y = [this.x, this.x = this.y][0];\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// make negative (return without changing self)\r\n\tnegative: function() {\r\n\t\treturn this.multiply_scalar(-1);\r\n\t},\r\n\r\n\t// make negative self (multiply by -1)\r\n\tnegative_self: function() {\r\n\t\tthis.multiply_scalar_self(-1);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// get distance from another vector\r\n\tdistance_from: function(other) {\r\n\t\treturn SSCD.Math.distance(this, other);\r\n\t},\r\n\r\n\t// get angle from another vector\r\n\tangle_from: function(other) {\r\n\t\treturn SSCD.Math.angle(this, other);\r\n\t},\r\n\r\n\t// move the position of this vector (same as add_self)\r\n\tmove: function(vector) {\r\n\t\tthis.x += vector.x;\r\n\t\tthis.y += vector.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// normalize this vector\r\n\tnormalize_self: function() {\r\n\t\tlet by = Math.sqrt(this.x * this.x + this.y * this.y);\r\n\t\tif (by === 0) return this;\r\n\t\tthis.x /= by;\r\n\t\tthis.y /= by;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// return normalized copy (don't change self)\r\n\tnormalize: function() {\r\n\t\treturn this.clone().normalize_self();\r\n\t},\r\n\r\n\t// add vector to self\r\n\tadd_self: function(other) {\r\n\t\tthis.x += other.x;\r\n\t\tthis.y += other.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// sub vector from self\r\n\tsub_self: function(other) {\r\n\t\tthis.x -= other.x;\r\n\t\tthis.y -= other.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// divide vector from self\r\n\tdivide_self: function(other) {\r\n\t\tthis.x /= other.x;\r\n\t\tthis.y /= other.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// multiple this vector with another\r\n\tmultiply_self: function(other) {\r\n\t\tthis.x *= other.x;\r\n\t\tthis.y *= other.y;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// add scalar to self\r\n\tadd_scalar_self: function(val) {\r\n\t\tthis.x += val;\r\n\t\tthis.y += val;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// substract scalar from self\r\n\tsub_scalar_self: function(val) {\r\n\t\tthis.x -= val;\r\n\t\tthis.y -= val;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// divide scalar from self\r\n\tdivide_scalar_self: function(val) {\r\n\t\tthis.x /= val;\r\n\t\tthis.y /= val;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// multiply scalar from self\r\n\tmultiply_scalar_self: function(val) {\r\n\t\tthis.x *= val;\r\n\t\tthis.y *= val;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// add to vector without changing self\r\n\tadd: function(other) {\r\n\t\treturn this.clone().add_self(other);\r\n\t},\r\n\r\n\t// sub from vector without changing self\r\n\tsub: function(other) {\r\n\t\treturn this.clone().sub_self(other);\r\n\t},\r\n\r\n\t// multiply vector without changing self\r\n\tmultiply: function(other) {\r\n\t\treturn this.clone().multiply_self(other);\r\n\t},\r\n\r\n\t// divide vector without changing self\r\n\tdivide: function(other) {\r\n\t\treturn this.clone().divide_self(other);\r\n\t},\r\n\r\n\t// add scalar without changing self\r\n\tadd_scalar: function(val) {\r\n\t\treturn this.clone().add_scalar_self(val);\r\n\t},\r\n\r\n\t// substract scalar without changing self\r\n\tsub_scalar: function(val) {\r\n\t\treturn this.clone().sub_scalar_self(val);\r\n\t},\r\n\r\n\t// multiply scalar without changing self\r\n\tmultiply_scalar: function(val) {\r\n\t\treturn this.clone().multiply_scalar_self(val);\r\n\t},\r\n\r\n\t// divide scalar without changing self\r\n\tdivide_scalar: function(val) {\r\n\t\treturn this.clone().divide_scalar_self(val);\r\n\t},\r\n\r\n\t// clamp vector values\r\n\tclamp: function(min, max) {\r\n\t\tif (this.x < min) this.x = min;\r\n\t\tif (this.y < min) this.y = min;\r\n\t\tif (this.x > max) this.x = max;\r\n\t\tif (this.y > max) this.y = max;\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// create vector from radian\r\n\tfrom_radian: function(rad) {\r\n\t\tthis.x = Math.cos(rad);\r\n\t\tthis.y = Math.sin(rad);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// create vector from radian\r\n\tfrom_angle: function(angle) {\r\n\t\treturn this.from_radian(SSCD.Math.to_radians(angle));\r\n\t},\r\n\t\r\n\t// apply a function on x and y components on self\r\n\tapply_self: function(func) {\r\n\t\tthis.x = func(this.x);\r\n\t\tthis.y = func(this.y);\r\n\t\treturn this;\r\n\t},\r\n\r\n\t// apply a function on x and y components\r\n\tapply: function(func) {\r\n\t\treturn this.clone().apply_self(func);\r\n\t},\r\n\r\n\t// print debug\r\n\tdebug: function() {\r\n\t\tconsole.debug(this.x + \", \" + this.y);\r\n\t}\r\n};\r\n\r\nSSCD.Vector.ZERO = new SSCD.Vector(0, 0);\r\nSSCD.Vector.ONE = new SSCD.Vector(1, 1);\r\nSSCD.Vector.UP = new SSCD.Vector(0, -1);\r\nSSCD.Vector.DOWN = new SSCD.Vector(0, 1);\r\nSSCD.Vector.LEFT = new SSCD.Vector(-1, 0);\r\nSSCD.Vector.RIGHT = new SSCD.Vector(1, 0);\r\nSSCD.Vector.UP_LEFT = new SSCD.Vector(-1, -1);\r\nSSCD.Vector.DOWN_LEFT = new SSCD.Vector(-1, 1);\r\nSSCD.Vector.UP_RIGHT = new SSCD.Vector(1, -1);\r\nSSCD.Vector.DOWN_RIGHT = new SSCD.Vector(1, 1);\r\n","/*\r\n * Tilemap is a special type of collision world, optimized specifically for a 2d tilemap.\r\n * Author: Ronen Ness, 2015\r\n */\r\n \r\n// a collision world. you create an instance of this class and add bodies to it to check collision.\r\n// @param tile_size: size, in pixels, of a single tile\r\n// @param additional_params: extra params. see SSCD.World for more info.\r\nimport {SSCD} from \"./sscdNameSpace\"\r\n\r\nSSCD.TilemapWorld = function(tile_size, additional_params) {\r\n\r\n\t// set defaults\r\n\tlet params = additional_params;\r\n\tparams = params || {};\r\n\tparams.grid_size = tile_size;\r\n\tthis.__tiles = {};\r\n\tthis.__init_world(params);\r\n};\r\n\r\n// tilemap collision world\r\nSSCD.TilemapWorld.prototype = {\r\n\r\n\t// set if a tile blocks or not.\r\n\t// @param index - the x and y index of the tile to set (vector).\r\n\t// @param collision - true if to put a collision shape on this tile, false otherwise.\r\n\t// @param tags - optional tags to apply on tile, if collision is set to true (note: null to reset tags).\r\n\tset_tile: function(index, collision, tags) {\r\n\t\t// if already have shape, get it\r\n\t\tlet shape = this.get_tile(index);\r\n\r\n\t\t// if requested to remove the collision from this tile, do it\r\n\t\tif (!collision) {\r\n\t\t\tif (shape) {\r\n\t\t\t\tthis.__set_tile_shape(index, null);\r\n\t\t\t\tthis.remove(shape);\r\n\t\t\t\t//delete shape;\r\n\t\t\t}\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// if got here it means we need to set collision / update tags for this tile.\r\n\t\t// first, check if need to create new collision shape.\r\n\t\tif (shape === undefined) {\r\n\t\t\t// calc position and size of the shape\r\n\t\t\tlet tilesize = this.__params.grid_size;\r\n\t\t\tlet position = index.multiply_scalar(tilesize);\r\n\t\t\tlet size = new SSCD.Vector(tilesize, tilesize);\r\n\r\n\t\t\t// create and add the shape\r\n\t\t\tshape = this.__add_tile_shape(new SSCD.Rectangle(position, size), index);\r\n\t\t\tthis.__set_tile_shape(index, shape);\r\n\t\t}\r\n\r\n\t\t// set collision tags\r\n\t\tif (tags !== undefined) {\r\n\t\t\tshape.set_collision_tags(tags);\r\n\t\t}\r\n\t},\r\n\r\n\t// add collision tile (for internal usage).\r\n\t// @param obj - object to add to the tile.\r\n\t// @param index - tile index.\r\n\t__add_tile_shape: function(obj, index) {\r\n\r\n\t\t// make sure lists exist\r\n\t\tthis.__grid[index.x] = this.__grid[index.x] || {};\r\n\t\tthis.__grid[index.x][index.y] = this.__grid[index.x][index.y] || [];\r\n\r\n\t\t// get current grid chunk\r\n\t\tlet curr_grid_chunk = this.__grid[index.x][index.y];\r\n\r\n\t\t// add object to grid chunk\r\n\t\tcurr_grid_chunk.push(obj);\r\n\r\n\t\t// add chunk to shape chunks list\r\n\t\tobj.__grid_chunks = [curr_grid_chunk];\r\n\r\n\t\t// set world and grid chunks boundaries\r\n\t\tobj.__world = this;\r\n\t\tobj.__grid_bounderies = {\r\n\t\t\tmin_x: index.x,\r\n\t\t\tmin_y: index.y,\r\n\t\t\tmax_x: index.x,\r\n\t\t\tmax_y: index.y\r\n\t\t};\r\n\t\t// obj.__last_insert_aabb = obj.get_aabb().clone();\r\n\r\n\t\t// add to list of all shapes\r\n\t\tthis.__all_shapes[obj.get_id()] = obj;\r\n\r\n\t\t// return the newly added object\r\n\t\treturn obj;\r\n\t},\r\n\r\n\t// set tilemap from a matrix (array of arrays).\r\n\t// @param matrix is the matrix to set, every 1 will be collision, every 0 will not collide. (note: true and false works too).\r\n\tset_from_matrix: function(matrix) {\r\n\t\tlet index = new SSCD.Vector(0, 0);\r\n\t\tfor (let i = 0; i < matrix.length; ++i) {\r\n\t\t\tindex.x = 0;\r\n\t\t\tfor (let j = 0; j < matrix[i].length; ++j) {\r\n\t\t\t\tthis.set_tile(index, matrix[i][j],null);\r\n\t\t\t\tindex.x++;\r\n\t\t\t}\r\n\t\t\tindex.y++;\r\n\t\t}\r\n\t},\r\n\r\n\t// get the collision shape of a tile (or undefined if have no collision shape on this tile).\r\n\t// @param index - the x and y index of the tile to get.\r\n\tget_tile: function(index) {\r\n\t\treturn this.__tiles[index.x + \"_\" + index.y];\r\n\t},\r\n\r\n\t// set the collision shape of a tile.\r\n\t// @param index - tile index.\r\n\t// @param shape - shape to set.\r\n\t__set_tile_shape: function(index, shape) {\r\n\t\tif (shape === null) {\r\n\t\t\tdelete this.__tiles[index.x + \"_\" + index.y];\r\n\t\t} else {\r\n\t\t\tthis.__tiles[index.x + \"_\" + index.y] = shape;\r\n\t\t}\r\n\t},\r\n\r\n};\r\n\r\n// inherit from basic world class.\r\nSSCD.extend(SSCD.World.prototype, SSCD.TilemapWorld.prototype);\r\n","//import {sscd as SSCD} from 'sscd';\r\nimport {SSCD} from '../src/sscd';\r\n//declare const SSCD:any;\r\nimport {Point2} from \"basictypes\";\r\nimport {EventEmitter} from \"eventemitter3\";\r\n\r\ninterface SSCDBody<T>{\r\n    set_position(vector);\r\n    get_position();\r\n    get_aabb():{position:Point2,size:Point2};\r\n    get_data():T\r\n    set_data(data:T)\r\n}\r\n\r\nconst ADD = \"ADD\";\r\nconst REMOVE = \"REMOVE\";\r\n\r\nexport class SimpleCollisionDetection<T> {\r\n    private world: any;\r\n    private emitter = new EventEmitter();\r\n\r\n    getType(): string {\r\n        //https://github.com/RonenNess/SSCD.js/\r\n        return SimpleCollisionDetection.name;\r\n    }\r\n\r\n    constructor() {\r\n        this.world = new SSCD.World();\r\n    }\r\n\r\n    onAdd(callback:(param: SSCDBody<T>)=>void):()=>void{\r\n        this.emitter.on(ADD,callback);\r\n        return ()=>{\r\n            this.emitter.off(ADD,callback);\r\n        }\r\n    }\r\n\r\n    onRemove(callback:(param: SSCDBody<T>)=>void):()=>void{\r\n        this.emitter.on(REMOVE,callback);\r\n        return ()=>{\r\n            this.emitter.off(REMOVE,callback);\r\n        }\r\n    }\r\n\r\n    register(param: SSCDBody<T>) {\r\n        this.world.add(param);\r\n        this.emitter.emit(ADD,param);\r\n    }\r\n\r\n    unregister(param: SSCDBody<T>) {\r\n        this.world.remove(param);\r\n        this.emitter.emit(REMOVE,param);\r\n    }\r\n\r\n    getObjectAt({x,y}: Point2):T {\r\n        let obj = this.world.pick_object(new SSCD.Vector(x, y));\r\n        return obj?obj.get_data():null;\r\n    }\r\n\r\n    getObjectsAt({x,y}: Point2):T[] {\r\n        let collision_list = [];\r\n        let shape = new SSCD.Vector(x, y);\r\n        this.world.test_collision(shape, undefined, collision_list)\r\n        return collision_list.map(obj => {\r\n            return obj ? obj.get_data() : null;\r\n        });\r\n    }\r\n\r\n    getObjectIn({x,y}: Point2, radius):T[] {\r\n        let collision_list = [];\r\n        let shape = new SSCD.Circle(new SSCD.Vector(x, y), radius);\r\n        this.world.test_collision(shape, undefined, collision_list)\r\n        return collision_list.map(obj => {\r\n            return obj ? obj.get_data() : null;\r\n        });\r\n    }\r\n\r\n    getWorld() {\r\n        return this.world;\r\n    }\r\n}\r\n"]}